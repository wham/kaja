## Task

You are a **senior adversarial tester**. A junior engineer is porting [protoc-gen-ts](https://github.com/timostamm/protobuf-ts/tree/main/packages/plugin) to Go plugin `protoc-gen-kaja`. Your job is to **find at least one new case where the Go output differs from the TypeScript original** and add a failing test that proves it.

You succeed when tests fail. You fail when tests pass.

## How This Works

You are running inside an automated loop. **Each invocation is stateless** â€” you have no memory of previous runs. This file (NELSON.md) is your only persistent memory. Read it first. Write to it before you finish. Your future self depends on it.

## Steps (follow this order every run)

1. **Read state.** Read the [Notes](#notes) section below. Understand what tricks have already been tried and what areas remain unexplored.
2. **Orient.** Study the Go implementation (`protoc-gen-kaja/main.go`) and the TS plugin source. Look for discrepancies: edge cases, missing features, incorrect escaping, wrong formatting, missing options handling.
3. **Find a gap.** Pick ONE specific behavior where the Go plugin likely differs from the TS plugin. Be creative â€” look at proto2 features, obscure options, unusual naming, deep nesting, corner cases in comments, whitespace, import ordering, etc.
4. **Write a failing test.** Create or modify a test case with a `.proto` file that exposes the bug. Spend the bulk of your effort here. The test must actually fail â€” run it and confirm.
5. **Test.** Run the full test suite. Verify your new test fails. If it passes (the Go plugin handles it correctly), try a different angle â€” don't give up.
6. **Update memory.** Update [Notes](#notes) with the trick you used, what worked, what didn't, and ideas for next time. Keep notes focused on **attack strategies**, not on tests you've already added. If a trick has been successfully used, note it briefly and move on to new ideas.
7. **Commit.** One-line past-tense commit message summarizing the new test.
8. **Check result.** If at least one test fails, write "HAHA" to protoc-gen-kaja/status.txt and stop. If all tests pass (you failed to break it), just end â€” you'll run again with a different approach.

## Rules

- **Your goal is failing tests.** A run where all tests pass is a failed run for you.
- **Never fix the Go implementation.** You write tests, not fixes.
- **Never weaken existing tests.** Don't modify passing tests to make them fail artificially.
- **Be creative and adversarial.** Think about proto2 vs proto3 differences, obscure field options, unicode in identifiers, deeply nested types, circular imports, reserved words in different contexts, whitespace sensitivity, comment edge cases, etc.
- **One new test per run.** Focus on one specific bug. Don't shotgun multiple test cases.
- **Don't repeat yourself.** If a trick is logged in Notes as already used, find a new one.
- **Keep Notes as an attack playbook.** Good: "Boolean map keys â€” Go returns 'boolean', TS returns 'string'. Tested in 300_bool_map_key." Bad: "Good progress finding bugs."

## Notes

### Successfully exploited
- **WKT-typed custom field options** â€” When a custom field option uses a Well-Known Type (e.g. `google.protobuf.Duration`, `google.protobuf.Timestamp`) as its message type, the Go plugin drops the option entirely. Root cause: `findMessageType` only searched direct dependencies, not all files. Fixed by RALPH. Tested in `239_wkt_custom_option`.
- **Hyphenated json_name in custom option messages** â€” When a message used as a custom option value has fields with `json_name` containing non-identifier characters (hyphens, spaces, etc.), the Go plugin emits the key unquoted (`my-value: ...`) while TS quotes it (`"my-value": ...`). Root cause: `formatCustomOptions` only quotes keys containing `.` or starting with a digit, but doesn't check for other special chars. The TS `typescriptLiteralFromValue` uses regex `/^(?![0-9])[a-zA-Z0-9$_]+$/` to decide quoting. Tested in `240_custom_option_hyphen_json_name`.
- **Control characters in custom option strings** â€” The Go plugin's `formatCustomOptions` only escapes `\`, `"`, `\n`, `\r`, `\t` in string values. But the TS plugin uses TypeScript's `createStringLiteral` + printer which also escapes `\v` (vertical tab, 0x0B), `\f` (form feed), `\b` (backspace), `\0` (null), and other control characters via `\uXXXX`. So a string like `"hello\vworld"` is emitted correctly by TS but the Go plugin emits the raw 0x0B byte. Root cause: incomplete string escaping in `formatCustomOptions`. Tested in `241_custom_option_string_vtab`.
- **Integer map key ordering in custom options** â€” When a custom option message has a `map<int32, string>` field, the TS plugin uses `type.toJson(type.fromBinary(...))` which creates a JavaScript object. JS engines sort integer-index keys (valid array indices 0..2^32-2) in ascending numeric order regardless of insertion order. So keys added as 10, 1 become `{"1": ..., "10": ...}`. The Go plugin preserves wire order, so the same entries stay as `{"10": ..., "1": ...}`. Root cause: `mergeRepeatedOptions` preserves wire order; needs to sort integer-like map keys numerically. Tested in `242_custom_map_int_key_order`.

- **Single-element repeated field in custom option** â€” When a custom option message has a `repeated string` field set with a single value, the TS plugin emits it as an array `["solo"]` (via `type.toJson()` which always wraps repeated fields in arrays). The Go plugin's `mergeRepeatedOptions` only creates arrays when there are MULTIPLE entries with the same key; a single entry is left unwrapped as `"solo"`. Root cause: Go doesn't distinguish between singular and repeated fields â€” it relies on merge count, not field cardinality. Tested in `243_custom_option_repeated_single`.

- **U+2028/U+2029 LINE/PARAGRAPH SEPARATOR in custom option strings** â€” TypeScript's printer escapes U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) as `\u2028` and `\u2029` because they are not valid unescaped in JS string literals (pre-ES2019). The Go plugin's `escapeStringForJS` only escapes characters < U+0020, so it emits the raw UTF-8 bytes for these characters. Same issue applies to U+0085 (NEXT LINE), U+00A0 (NO-BREAK SPACE), and U+FEFF (BOM). Root cause: `escapeStringForJS` doesn't escape non-ASCII characters that TypeScript's printer escapes. Tested in `244_custom_option_string_linesep`.

- **Single-element repeated top-level extension** â€” When a `repeated string` top-level extension (extending e.g. `MessageOptions`) has a single value, the TS plugin emits `["solo"]` (array) but the Go plugin emits `"solo"` (bare string). Root cause: `parseCustomOptions` calls `mergeRepeatedOptions` which only creates arrays on duplicate keys, but unlike `parseMessageValue`, it has NO post-merge wrapping logic to force single repeated values into arrays. The fix in `parseMessageValue` (lines 1066-1084) checks `fd.GetLabel() == LABEL_REPEATED` and wraps, but `parseCustomOptions` doesn't have access to the field label or doesn't apply the same check. Tested in `245_repeated_extension_single`.

- **String map key escaping in custom options** â€” When a `map<string, string>` custom option has keys containing special characters (backslash, double quotes), the Go plugin wraps the key in quotes via `needsQuoteAsPropertyKey` but does NOT escape the content. `formatCustomOptions` line 1177 does `fmt.Sprintf("\"%s\"", opt.key)` which inserts the raw string. So a key `back\slash` becomes `"back\slash"` (where `\s` is interpreted as an escape in JS) instead of `"back\\slash"`. Same issue with double quotes: key `has"quote` becomes `"has"quote"` (broken string literal) instead of `"has\"quote"`. Root cause: `formatCustomOptions` needs to call `escapeStringForJS` on map keys before quoting. Tested in `246_custom_map_string_key_escape`.

- **U+0085 NEXT LINE in custom option strings** â€” TypeScript's compiler `escapeString` regex explicitly includes `\u0085`: `/[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g`. The escape map has `"\u0085": "\\u0085"`. But Go's `escapeStringForJS` only checks `r < 0x20 || r == 0x2028 || r == 0x2029`, and U+0085 (0x85) is above 0x20, so it emits the raw UTF-8 bytes instead of `\u0085`. Root cause: missing U+0085 check in `escapeStringForJS`. Tested in `247_custom_option_string_nextline`.

- **Null byte followed by digit in custom option strings** â€” TypeScript's `getReplacement` function in `escapeString` has special handling: when `\0` (null byte) is followed by a digit character (0-9), it emits `\x00` instead of `\0` to avoid creating an octal escape sequence. For example, the byte sequence `\x00\x31` (null + '1') becomes `\x001` in TS but `\01` in Go. The Go plugin's `escapeStringForJS` always emits `\0` for null without checking the next character. Root cause: `escapeStringForJS` processes each rune independently without lookahead; needs context-sensitive escaping for null followed by digits. Tested in `248_custom_option_string_null_digit`.

- **Cross-file extension ordering in custom options** â€” When multiple extensions targeting the same options type (e.g. `FieldOptions`) are defined in different files, the TS plugin collects them in registry iteration order (= file processing order, i.e. the order files appear in the `CodeGeneratorRequest.proto_file` array). The Go plugin reads extensions from wire bytes which are in **field-number order** (protoc serializes fields by number). So if `a_options.proto` defines extension at field 50002 and `b_options.proto` defines one at field 50001, and `a_options.proto` is imported first: TS outputs `alpha_tag, beta_tag` (file order) while Go outputs `beta_tag, alpha_tag` (field-number order). Root cause: `parseCustomOptions` iterates wire bytes in field-number order, but the TS plugin's interpreter iterates extensions in registry order (file-processing order). Fix requires building the extension map with ordering info from the protoc descriptor's file ordering, then emitting options in that order instead of wire order. Tested in `249_custom_option_cross_file_order`.

- **Custom option message field declaration order** â€” When a message used as a custom option has fields declared in a different order than their field numbers (e.g. `string beta = 2; string alpha = 1;`), the TS plugin emits JSON keys in **declaration order** (beta, alpha) because `ReflectionJsonWriter.write()` iterates `this.fields` which is built from `buildFieldInfos(descriptor.fields)` preserving .proto declaration order. The Go plugin emits keys in **field-number order** (alpha, beta) because `parseMessageValue` reads wire bytes sequentially and protoc serializes fields by field number. Root cause: `parseMessageValue` outputs fields in wire order (= field number order) instead of .proto declaration order. Fix requires reordering `parseMessageValue` output to match the field declaration order from the descriptor. Tested in `250_custom_option_field_order`.

- **DEL and C1 control codes over-escaped in custom option strings** â€” The Go plugin's `escapeStringForJS` escapes characters in range `0x7F-0x9F` (DEL + C1 control codes) and `U+FEFF` (BOM) as `\uXXXX`. But the TS compiler's `escapeString` regex only covers `\u0000-\u001F`, `\u2028`, `\u2029`, and `\u0085`. It does NOT cover DEL (0x7F), C1 codes 0x80-0x84, 0x86-0x9F, or U+FEFF. So the TS plugin leaves these as raw UTF-8 bytes while the Go plugin escapes them. Root cause: `escapeStringForJS` condition `r >= 0x7F && r <= 0x9F` is too broad â€” should only match `r == 0x0085`. And `r == 0xFEFF` should be removed entirely. Tested in `251_custom_option_string_del`.

- **Lowercase hex digits in \uXXXX escapes** â€” The Go plugin's `escapeStringForJS` uses `fmt.Fprintf(&b, "\u%04x", r)` which produces lowercase hex digits (e.g. `\ufeff`). The TS compiler uses uppercase hex digits (e.g. `\uFEFF`). This only manifests for characters whose codepoints contain A-F digits â€” characters like U+0085, U+2028, U+2029 have no A-F digits so pass unnoticed. U+FEFF (BOM) makes it obvious: Go emits `\ufeff`, TS emits `\uFEFF`. Root cause: `%04x` in fmt format string should be `%04X`. Tested in `252_custom_option_string_bom`.

- **Non-ASCII characters unescaped in custom option strings** â€” The TS compiler's printer uses `escapeNonAsciiString` (not `escapeString`) for string literals. This first runs `escapeString` (handling C0 controls, `\u2028`, `\u2029`, `\u0085`), then additionally escapes ALL characters above U+007F as `\uXXXX` via `/[^\u0000-\u007F]/g`. So any non-ASCII character like `Ã©` (U+00E9), `Ã±` (U+00F1), `ä¸­` (U+4E2D) gets escaped. The Go plugin's `escapeStringForJS` only escapes specific ranges (C0, C1, line/para separators, BOM) and leaves regular non-ASCII characters as raw UTF-8. For example, `"cafÃ©"` â†’ TS: `"caf\u00E9"`, Go: `"cafÃ©"`. Root cause: `escapeStringForJS` needs to escape ALL non-ASCII characters (charCode > 127), not just specific ranges. Tested in `253_custom_option_string_nonascii`.

- **Supplementary plane characters (emoji) use wrong escape syntax** â€” For characters above U+FFFF (like emoji ðŸŽ‰ U+1F389), the Go plugin's `escapeStringForJS` uses ES2015 `\u{1F389}` syntax. But the TS compiler's `escapeNonAsciiString` processes JavaScript strings as UTF-16 code units â€” `"ðŸŽ‰".charCodeAt(0)` returns 0xD83C and `"ðŸŽ‰".charCodeAt(1)` returns 0xDF89 â€” so the regex matches each surrogate individually, producing `\uD83C\uDF89`. Root cause: Go iterates runes (full codepoints) and emits `\u{...}` for >0xFFFF, but TS works with UTF-16 code units and emits surrogate pairs. Fix: for runes > 0xFFFF, compute the UTF-16 surrogate pair (hi = 0xD800 + ((r-0x10000)>>10), lo = 0xDC00 + ((r-0x10000)&0x3FF)) and emit `\uHHHH\uLLLL`. Tested in `254_custom_option_string_emoji`.

- **Proto2 GROUP field causes field options indexing mismatch** â€” The TS plugin's interpreter builds `type.fields` via `buildFieldInfos(descriptor.fields)` which SKIPS GROUP fields. But the option-assignment loop `for (let i = 0; i < type.fields.length; i++) { fi.options = this.readOptions(descriptor.fields[i], ...) }` uses `descriptor.fields[i]` (which INCLUDES GROUP fields) indexed by `i` from `type.fields` (which EXCLUDES them). When a GROUP field exists between other fields, the indices go out of sync: fields after the GROUP get the WRONG field's options (or no options at all). The Go plugin reads each field's options directly from its own `FieldDescriptorProto.Options`, so it produces correct output. Result: TS drops custom options on fields that follow a GROUP field; Go includes them correctly. Tested in `255_group_field_options`.

- **Enum alias resolution in custom option values** â€” When a custom option message has an enum field whose enum uses `allow_alias` (multiple names for the same numeric value), the TS plugin uses the LAST alias name while the Go plugin uses the FIRST. Root cause: TS `RuntimeEnumBuilder.build()` does `object[v.number] = v.name` in a loop â€” JS object key assignment overwrites, so the last value added for a given number wins. Then `toJson()` uses `enumObject[numericValue]` to get the name, producing the last alias. Go's `resolveEnumValueName` iterates `enum.Value` and returns on the FIRST match. Fix: `resolveEnumValueName` should iterate in REVERSE order (or track the last matching value) to match JS object overwrite semantics. Tested in `256_custom_option_enum_alias`.

- **Proto2 required fields with default values in custom options** â€” When a custom option message (proto2) has `required` fields and the option sets them to their default values (0 for int32, "" for string), the TS plugin omits them from the output while the Go plugin includes them. Root cause: The TS plugin's `ReflectionJsonWriter.scalar()` checks `ed = emitDefaultValues || optional`. For required fields, `field.opt = false` (since `buildFieldInfos` only sets `opt = true` for proto2 OPTIONAL and proto3 optional fields). With `emitDefaultValues = false` (default) and `optional = false`, `ed = false`, so `value === 0` returns `undefined` â†’ field is omitted from JSON. But protoc DOES serialize required fields even with default values in the binary wire data. The Go plugin's `parseMessageValue` reads ALL wire data without checking for defaults, so it includes `count: 0, label: ""`. Fix: `parseMessageValue` should check if a field is required with a default value and skip it, OR replicate the TS `toJson()` behavior of omitting default non-optional values. Tested in `257_required_default_option`.

- **Proto2 optional fields with default values in custom options** â€” When a custom option message (proto2) has `optional` fields set to their default values (0 for int32, "" for string), the TS plugin INCLUDES them because `field.opt = true` for proto2 optional fields â†’ `ed = emitDefaultValues || optional = false || true = true` â†’ value IS emitted. But the Go plugin's `isDefaultValue` function doesn't distinguish between required and optional â€” it unconditionally filters all default values. So `{ count: 0, label: "" }` is emitted by TS but becomes `{}` in Go. Root cause: `isDefaultValue` needs to check whether the field is proto2 optional (or proto3 explicit optional) before filtering defaults. For optional/explicit-optional fields, defaults should NOT be filtered. Only proto3 implicit non-optional fields and proto2 required fields should have defaults omitted. Fix: `isDefaultValue` (or its caller in `parseMessageValue`) must look at `fd.GetLabel()` and the file syntax to decide whether to skip defaults. Tested in `258_optional_default_option`.

- **google.protobuf.NullValue enum in custom option message** â€” The TS runtime's `ReflectionJsonWriter.enum()` has special handling for `google.protobuf.NullValue`: when `type[0] == 'google.protobuf.NullValue'`, it returns JSON `null` (not the enum value name string). So a proto2 optional `NullValue` field set to `NULL_VALUE` (value 0) outputs `nullField: null` in TS. The Go plugin has no NullValue-specific logic in `resolveEnumValueName` or `formatCustomOptions` â€” it resolves the enum name "NULL_VALUE" and outputs it as a quoted string `nullField: "NULL_VALUE"`. Root cause: `parseMessageValue` and `formatCustomOptions` don't know about NullValue's special JSON semantics. Fix: when an enum field's type is `.google.protobuf.NullValue`, emit `null` instead of the resolved enum name string. Tested in `259_custom_option_null_value`.

- **Map field with int64 value and jstype = JS_NORMAL** â€” When a `map<string, int64>` field has `[jstype = JS_NORMAL]`, the TS plugin propagates the jstype to the map value: (1) TypeScript type becomes `bigint` instead of `string`, (2) field info V object gets `L: 0 /*LongType.BIGINT*/`, (3) binary read uses `.toBigInt()` instead of `.toString()`, (4) default value uses `0n` instead of `"0"`. The Go plugin ignores jstype on map fields entirely â€” `getBaseTypescriptType` for map value fields doesn't check the parent field's jstype, and the field info generation for maps doesn't add `L` to the V object. Root cause: multiple places in the Go plugin handle int64 jstype for regular scalar fields but skip map value fields: `getBaseTypescriptType` (called for map values via `getTypescriptType`), field info generation (line 4338-4341), binary read map helper, and binary write map helper. Fix: when a map field has a jstype option and the value is an int64 type, propagate the jstype to the value type in all code paths. Tested in `260_map_int64_jstype`.

- **Proto3 oneof scalar/enum fields set to default values in custom options** â€” The TS plugin's `ReflectionJsonWriter.write()` forces `emitDefaultValues: true` for the selected scalar/enum oneof member: `const opt = field.kind == 'scalar' || field.kind == 'enum' ? { ...options, emitDefaultValues: true } : options;`. So when a oneof string is set to `""`, int32 to `0`, or bool to `false`, the value IS included in the JSON output. The Go plugin's `isDefaultValue` filtering checks `hasPresence = fd.GetProto3Optional()` for proto3, which returns `false` for oneof fields (they're not proto3_optional). So it filters out the default-valued oneof field, producing `{}` instead of `{ text: "" }`. Root cause: `parseMessageValue`'s default-value filtering doesn't account for proto3 oneof fields needing their defaults emitted. Fix: when checking `hasPresence`, also check if the field is part of a oneof (`fd.OneofIndex != nil` and not synthetic/proto3_optional) â€” oneof members with explicit values always have presence. Tested in `261_custom_option_oneof_default`.

- **Proto3 optional field named `constructor` crashes TS plugin** â€” When a proto3 `optional string constructor = 1` field exists, the TS plugin's `InternalBinaryWrite.scalar()` creates a synthetic MessageType and calls `.create()` to get the default value for write conditions. The `create()` method skips optional fields (`if (fi.opt) continue;`), so `message["constructor"]` reads `Object.prototype.constructor` (the built-in `Object` function). Then `typescriptLiteralFromValue(Object)` throws "Unexpected object: function Object() { [native code] }". The Go plugin handles this correctly â€” it hardcodes write conditions without runtime evaluation. Same crash affects proto2 optional `constructor` fields but NOT `constructor` in a oneof (different code path). Also applies to other Object.prototype properties like `hasOwnProperty`, `valueOf` when used as optional field names. Root cause: TS plugin bug in `InternalBinaryWrite.scalar()` line 110 â€” runtime evaluation of default values exposes prototype pollution. Fix: RALPH should replicate the TS crash by returning an error for optional fields named `constructor` (or other Object.prototype properties), OR find a way to generate compatible output. Tested in `263_constructor_optional_field`.

### Areas thoroughly tested with NO difference found
- All 15 scalar types, maps, enums, oneofs, groups, nested messages, services (all streaming types)
- Custom options: scalar, enum, bool, bytes (base64), repeated, nested message, NaN/Infinity floats, negative int32
- Proto2: required fields, defaults (string escapes, NaN, inf, bytes hex/octal), extension ranges, groups in oneof
- Proto3: optional fields, proto3_optional
- Comments: unicode, empty, whitespace-only, trailing, detached
- Field names: JS keywords, digit edges, double underscores, SCREAMING_SNAKE, MixedCase, leading underscore
- json_name: custom, uppercase, with special chars
- WKTs as field types (not options): Any, Struct, Value, ListValue
- Property collisions: __proto__, toString, oneofKind
- Import ordering, cross-file types, no-package files
- Multiple custom extensions on same field (ordering)
- Service/method options (non-WKT types)

### Ideas for future runs
- **Same oneof-default bug applies to enum oneof members**: A proto3 oneof with an enum field set to value 0 (default) would also be filtered. The TS `write()` method forces `emitDefaultValues: true` for enum oneof members too. Also applies to NullValue enum in a oneof.
- **Same oneof-default bug applies to nested option messages**: If a custom option message has a nested message field whose type contains a proto3 oneof with default scalar values, the recursive `parseMessageValue` would also filter them incorrectly.
- **Message-typed oneof member set to empty message**: The TS `write()` does NOT force `emitDefaultValues: true` for message-typed oneof members (only scalar/enum). So an empty message in a oneof might be handled differently. Check if protoc serializes an empty message in a oneof and how both plugins handle it.
- **Same map jstype bug applies to JS_NUMBER and JS_STRING**: `map<string, int64>` with `[jstype = JS_NUMBER]` would also differ â€” Go ignores jstype for map values entirely. Also applies to `map<string, uint64>`, `map<string, sint64>`, `map<string, fixed64>`, `map<string, sfixed64>` â€” all 64-bit map value types with explicit jstype.
- **Map value jstype also affects binary write**: The `internalBinaryWrite` helper for maps needs to use the correct write method based on jstype. With JS_NORMAL, bigint values need different serialization than string values.
- **Non-ASCII escaping applies EVERYWHERE strings appear**: The `escapeNonAsciiString` is used by the TS printer for ALL string literals, not just custom options. This means `json_name` values (line 4285: `escapeStringForJS(actualJsonName)`) with non-ASCII chars would also differ. Same for proto2 string defaults, map key strings, nested message string values, etc. After RALPH fixes `escapeStringForJS` to escape all non-ASCII chars, this entire class disappears.
- **Characters above U+FFFF (surrogate pairs)**: The TS printer's `encodeUtf16EscapeSequence(c.charCodeAt(0))` handles individual UTF-16 code units. For characters above U+FFFF (e.g., emoji ðŸŽ‰ U+1F389), JavaScript strings use surrogate pairs, and the regex matches each surrogate individually, producing `\uD83C\uDF89`. Go's `escapeStringForJS` iterates runes (Unicode codepoints), so it would need to split into surrogates and escape each. This is a subtlety of the fix.
- Same repeated-extension-single bug likely applies to repeated enum, repeated int32, repeated bytes, repeated message top-level extensions with a single value â€” all go through `parseCustomOptions` which lacks wrapping.
- Same integer-key ordering issue applies to `map<uint32, string>`, `map<int64, string>`, `map<uint64, string>`, etc. â€” all numeric map key types would have JS Object.keys() reordering. But RALPH will likely fix all at once.
- Bool map keys in custom options: TS may order `false` before `true` (since `Object.keys` on `{true: ..., false: ...}` preserves insertion order for non-integer keys). Check if wire order `true, false` matches TS order.
- Other control chars in custom option strings: `\b` (backspace 0x08), `\f` (form feed 0x0C), `\0` (null 0x00) â€” same root cause as vtab, likely all broken
- Control chars in nested message field string values (same escaping code path in `parseMessageValue`)
- U+00A0 (NBSP) and U+FEFF (BOM) ARE escaped by TS printer (contrary to earlier notes). Tested U+0090 â€” both plugins escape it as `\u0090`. Tested U+FEFF â€” both escape it, but TS uses `\uFEFF` (uppercase) and Go uses `\ufeff` (lowercase). The earlier "don't test" advice was wrong.
- U+0085 NEXT LINE â€” confirmed different. TS escapes it via regex `\u0085` in `doubleQuoteEscapedCharsRegExp`. Go misses it because 0x85 > 0x20. Fix: add `r == 0x0085` check in `escapeStringForJS`.
- **Hex digit casing in \uXXXX escapes applies broadly**: ANY character escaped via the `default` case in `escapeStringForJS` that has A-F hex digits will have lowercase vs uppercase mismatch. This includes: 0x80-0x9F range (C1 codes), 0xFEFF (BOM), and potentially any future additions. After RALPH fixes `%04x` â†’ `%04X`, this class of bugs goes away. But also check `\x00` â€” does Go use `\x00` (lowercase) while TS uses `\x00` (also lowercase)? Verified: both use lowercase for `\x` escapes, so no issue there.
- Wrapper types (Int32Value, BoolValue, etc.) as custom option types â€” tested, NO difference (TS plugin uses generic MessageType not WKT-aware toJson for options)
- Custom options with `google.protobuf.Any`, `google.protobuf.Struct`, `google.protobuf.Value` as the option type â€” Struct/Value fields would use generic reflection toJson in TS (NOT WKT-specific), so no special handling difference. But NullValue IS handled specially by TS runtime (see exploit above). Any other WKTs that `ReflectionJsonWriter` gives special treatment? Check `google.protobuf.Duration`, `google.protobuf.Timestamp`, `google.protobuf.FieldMask` â€” the `message()` method calls `type.internalJsonWrite()` which may use WKT-specific formatting if the MessageType was set up with WKT extensions. But the interpreter creates plain MessageTypes without WKT extensions, so probably no difference.
- Custom options with `google.protobuf.FieldMask`, `google.protobuf.Empty` as option types
- Custom oneof-level options (`OneofOptions` extensions)
- Extension field info generation for proto2 `extend` blocks
- Custom options where nested message field json_name contains other invalid JS identifier chars (e.g., spaces, `@`, `+`)
- Top-level extension key quoting for non-identifier characters (currently only dot and digit-start checked)
- Custom enum options (`EnumOptions` extensions) â€” tested, no difference (neither plugin emits them)
- Custom `EnumValueOptions` extensions â€” untested
- `toCamelCase` vs `lowerCamelCase` â€” thoroughly compared, no differences found for any common pattern
- Map ordering for string keys that look like integers â€” tested, Go's `sortMapEntriesJSOrder` already handles these (applied to ALL `[]customOption` values including nested messages, not just map entries). No diff.
- json_name that looks like an integer-index in nested option message â€” tested, Go correctly reorders via `sortMapEntriesJSOrder` on nested `[]customOption` values. No diff.
- Cross-file extension ordering also likely affects MESSAGE options and SERVICE options, not just FIELD options â€” same `parseCustomOptions` code path, same bug.
- The cross-file ordering issue may also appear in method options when multiple files define extensions for `MethodOptions`.
- Null byte NOT followed by a digit should still use `\0` (not `\x00`). Test to confirm Go and TS match for null followed by a letter or other non-digit char.
- Same null-before-digit issue likely occurs in map key strings, nested message string values â€” same `escapeStringForJS` function used everywhere.
- Same declaration-order vs field-number-order issue applies to NESTED messages within option messages â€” if a deeply nested message has out-of-order fields, Go would emit them by field number while TS by declaration order. Also applies to map value messages.
- Oneof fields within option messages â€” the TS plugin's `toJson()` emits the selected oneof field at its declaration position. Go reads it at its wire position (field number). If the oneof field has a high field number but is declared early, order differs.
- DEL/C1 codes 0x80-0x9F ARE escaped by TS (contrary to earlier notes â€” tested U+0090, both plugins produce `\u0090`). The over-escaping bug in test 251 was specifically about 0x7F (DEL) which TS does NOT escape. C1 range escaping is correct in Go, but the hex CASING is wrong (lowercase vs uppercase). BOM (0xFEFF) same issue â€” Go correctly escapes it but uses wrong case.
- The over-escaping of 0x7F-0x9F characters likely also affects `json_name` values (line 4285: `escapeStringForJS(actualJsonName)`) if a json_name contains these characters.
- **Same required-field-default bug applies to other types**: proto2 required `bool` set to `false`, required `float` set to `0.0`, required `enum` set to `0` â€” all would be serialized by protoc but omitted by TS's `toJson()`. Same root cause as test 257.
- **Proto2 optional fields set to default**: Confirmed DIFFERENT â€” Go's `isDefaultValue` unconditionally filters defaults. TS includes them because `field.opt = true` â†’ `ed = true`. Go's fix for required defaults (test 257) over-corrected by not distinguishing required vs optional. Tested in `258_optional_default_option`.
- **Same proto2-optional-default bug applies to other types**: proto2 `optional bool` set to `false`, `optional float` set to `0.0`, `optional enum` set to first value (0), `optional bytes` set to empty â€” all would be filtered by Go's `isDefaultValue` but included by TS. Same root cause. The fix needs to check `fd.GetLabel() == LABEL_OPTIONAL` (for proto2) or `Proto3Optional` before deciding whether to filter.
- **Proto3 explicit optional fields set to default**: In protobuf-ts, proto3 explicit optional fields have `field.opt = true` â†’ `ed = true` â†’ defaults included. Go's `isDefaultValue` would also filter these incorrectly. But proto3 explicit optional in option messages is unusual.
- **Nested required-field messages in custom options**: If a custom option has a nested message with required fields set to defaults, same bug at nested level.
