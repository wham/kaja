import { QuirksClient } from "./quirks.client";
import { SearchServiceClient } from "./search-service.client";
import { RpcTransport, ServiceInfo } from "@protobuf-ts/runtime-rpc";
export const model = { gens: [{ path: "kaja-twirp.ts", content: "import { TwirpFetchTransport } from \"@protobuf-ts/twirp-transport\";\nimport { QuirksClient } from \"./quirks.client\";\nimport { SearchServiceClient } from \"./search-service.client\";\nexport const model = { services: [{ name: \"Quirks\", methods: [{ name: \"GetAuthentication\", code: \"Quirks.GetAuthentication();\\n\" }, { name: \"Map\", code: \"Quirks.Map();\\n\" }, { name: \"MethodWithAReallyLongNameGmthggupcbmnphflnnvu\", code: \"Quirks.MethodWithAReallyLongNameGmthggupcbmnphflnnvu();\\n\" }, { name: \"Panic\", code: \"Quirks.Panic();\\n\" }, { name: \"Repeated\", code: \"Quirks.Repeated();\\n\" }, { name: \"Types\", code: \"Quirks.Types();\\n\" }], proxy: { GetAuthentication: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.getAuthentication(({} as any)); (window as any).GOUT(response); return response; }, Map: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.map(({} as any)); (window as any).GOUT(response); return response; }, MethodWithAReallyLongNameGmthggupcbmnphflnnvu: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.methodWithAReallyLongNameGmthggupcbmnphflnnvu(({} as any)); (window as any).GOUT(response); return response; }, Panic: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.panic(({} as any)); (window as any).GOUT(response); return response; }, Repeated: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.repeated(({} as any)); (window as any).GOUT(response); return response; }, Types: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new QuirksClient(transport); var { response } = await client.types(({} as any)); (window as any).GOUT(response); return response; } }, extraLib: \"const Quirks = { GetAuthentication: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.getAuthentication(({} as any)); (window as any).GOUT(response); return response; }, Map: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.map(({} as any)); (window as any).GOUT(response); return response; }, MethodWithAReallyLongNameGmthggupcbmnphflnnvu: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.methodWithAReallyLongNameGmthggupcbmnphflnnvu(({} as any)); (window as any).GOUT(response); return response; }, Panic: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.panic(({} as any)); (window as any).GOUT(response); return response; }, Repeated: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.repeated(({} as any)); (window as any).GOUT(response); return response; }, Types: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new QuirksClient(transport); var { response } = await client.types(({} as any)); (window as any).GOUT(response); return response; } };\\n\" }, { name: \"SearchService\", methods: [{ name: \"Search\", code: \"SearchService.Search();\\n\" }, { name: \"Index\", code: \"SearchService.Index();\\n\" }], proxy: { Search: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new SearchServiceClient(transport); var { response } = await client.search(({} as any)); (window as any).GOUT(response); return response; }, Index: async () => { var transport = new TwirpFetchTransport({ baseUrl: \"http://localhost:3000/twirp\" }); var client = new SearchServiceClient(transport); var { response } = await client.index(({} as any)); (window as any).GOUT(response); return response; } }, extraLib: \"const SearchService = { Search: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new SearchServiceClient(transport); var { response } = await client.search(({} as any)); (window as any).GOUT(response); return response; }, Index: async () => { var transport = new TwirpFetchTransport({ baseUrl: \\\"http://localhost:3000/twirp\\\" }); var client = new SearchServiceClient(transport); var { response } = await client.index(({} as any)); (window as any).GOUT(response); return response; } };\\n\" }], extraLibs: [{ filePath: \"google/protobuf/timestamp.proto.proto.ts\", content: \"\" }, { filePath: \"lib/message.proto.proto.ts\", content: \"\" }, { filePath: \"quirks.proto.proto.ts\", content: \"/**\\n * @generated from protobuf service quirks.v1.Quirks\\n */\\nexport interface IQuirksClient {\\n    /**\\n     * @generated from protobuf rpc: GetAuthentication(quirks.v1.Void) returns (lib.Message);\\n     */\\n    getAuthentication(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\\n    /**\\n     * @generated from protobuf rpc: Map(quirks.v1.MapRequest) returns (quirks.v1.MapRequest);\\n     */\\n    map(input: MapRequest, options?: RpcOptions): UnaryCall<MapRequest, MapRequest>;\\n    /**\\n     * @generated from protobuf rpc: MethodWithAReallyLongNameGmthggupcbmnphflnnvu(quirks.v1.Void) returns (lib.Message);\\n     */\\n    methodWithAReallyLongNameGmthggupcbmnphflnnvu(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\\n    /**\\n     * @generated from protobuf rpc: Panic(quirks.v1.Void) returns (lib.Message);\\n     */\\n    panic(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\\n    /**\\n     * @generated from protobuf rpc: Repeated(quirks.v1.RepeatedRequest) returns (quirks.v1.RepeatedRequest);\\n     */\\n    repeated(input: RepeatedRequest, options?: RpcOptions): UnaryCall<RepeatedRequest, RepeatedRequest>;\\n    /**\\n     * @generated from protobuf rpc: Types(quirks.v1.TypesRequest) returns (quirks.v1.TypesRequest);\\n     */\\n    types(input: TypesRequest, options?: RpcOptions): UnaryCall<TypesRequest, TypesRequest>;\\n}\\n\" }, { filePath: \"search-service.proto.proto.ts\", content: \"/**\\n * @generated from protobuf service SearchService\\n */\\nexport interface ISearchServiceClient {\\n    /**\\n     * @generated from protobuf rpc: Search(SearchRequest) returns (SearchResponse);\\n     */\\n    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse>;\\n    /**\\n     * @generated from protobuf rpc: Index(IndexRequest) returns (IndexResponse);\\n     */\\n    index(input: IndexRequest, options?: RpcOptions): UnaryCall<IndexRequest, IndexResponse>;\\n}\\n\" }] };\n" }, { path: "quirks.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"quirks.proto\" (package \"quirks.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { Quirks } from \"./quirks\";\nimport type { TypesRequest } from \"./quirks\";\nimport type { RepeatedRequest } from \"./quirks\";\nimport type { MapRequest } from \"./quirks\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { Message } from \"./lib/message\";\nimport type { Void } from \"./quirks\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service quirks.v1.Quirks\n */\nexport interface IQuirksClient {\n    /**\n     * @generated from protobuf rpc: GetAuthentication(quirks.v1.Void) returns (lib.Message);\n     */\n    getAuthentication(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Map(quirks.v1.MapRequest) returns (quirks.v1.MapRequest);\n     */\n    map(input: MapRequest, options?: RpcOptions): UnaryCall<MapRequest, MapRequest>;\n    /**\n     * @generated from protobuf rpc: MethodWithAReallyLongNameGmthggupcbmnphflnnvu(quirks.v1.Void) returns (lib.Message);\n     */\n    methodWithAReallyLongNameGmthggupcbmnphflnnvu(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Panic(quirks.v1.Void) returns (lib.Message);\n     */\n    panic(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Repeated(quirks.v1.RepeatedRequest) returns (quirks.v1.RepeatedRequest);\n     */\n    repeated(input: RepeatedRequest, options?: RpcOptions): UnaryCall<RepeatedRequest, RepeatedRequest>;\n    /**\n     * @generated from protobuf rpc: Types(quirks.v1.TypesRequest) returns (quirks.v1.TypesRequest);\n     */\n    types(input: TypesRequest, options?: RpcOptions): UnaryCall<TypesRequest, TypesRequest>;\n}\n/**\n * @generated from protobuf service quirks.v1.Quirks\n */\nexport class QuirksClient implements IQuirksClient, ServiceInfo {\n    typeName = Quirks.typeName;\n    methods = Quirks.methods;\n    options = Quirks.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetAuthentication(quirks.v1.Void) returns (lib.Message);\n     */\n    getAuthentication(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Map(quirks.v1.MapRequest) returns (quirks.v1.MapRequest);\n     */\n    map(input: MapRequest, options?: RpcOptions): UnaryCall<MapRequest, MapRequest> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<MapRequest, MapRequest>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: MethodWithAReallyLongNameGmthggupcbmnphflnnvu(quirks.v1.Void) returns (lib.Message);\n     */\n    methodWithAReallyLongNameGmthggupcbmnphflnnvu(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Panic(quirks.v1.Void) returns (lib.Message);\n     */\n    panic(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Repeated(quirks.v1.RepeatedRequest) returns (quirks.v1.RepeatedRequest);\n     */\n    repeated(input: RepeatedRequest, options?: RpcOptions): UnaryCall<RepeatedRequest, RepeatedRequest> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RepeatedRequest, RepeatedRequest>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Types(quirks.v1.TypesRequest) returns (quirks.v1.TypesRequest);\n     */\n    types(input: TypesRequest, options?: RpcOptions): UnaryCall<TypesRequest, TypesRequest> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<TypesRequest, TypesRequest>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "quirks.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"quirks.proto\" (package \"quirks.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Timestamp } from \"./google/protobuf/timestamp\";\nimport { Message } from \"./lib/message\";\n/**\n * @generated from protobuf message quirks.v1.MapRequest\n */\nexport interface MapRequest {\n    /**\n     * @generated from protobuf field: map<string, string> string_string = 1;\n     */\n    stringString: {\n        [key: string]: string;\n    };\n    /**\n     * @generated from protobuf field: map<string, int32> string_int32 = 2;\n     */\n    stringInt32: {\n        [key: string]: number;\n    };\n    /**\n     * @generated from protobuf field: map<sint64, string> sint64_string = 3;\n     */\n    sint64String: {\n        [key: string]: string;\n    };\n    /**\n     * @generated from protobuf field: map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string = 4;\n     */\n    stringRepeatedString: {\n        [key: string]: MapRequest_RepeatedString;\n    };\n}\n/**\n * @generated from protobuf message quirks.v1.MapRequest.RepeatedString\n */\nexport interface MapRequest_RepeatedString {\n    /**\n     * @generated from protobuf field: repeated string value = 1;\n     */\n    value: string[];\n}\n/**\n * @generated from protobuf message quirks.v1.RepeatedRequest\n */\nexport interface RepeatedRequest {\n    /**\n     * @generated from protobuf field: repeated string string = 1;\n     */\n    string: string[];\n    /**\n     * @generated from protobuf field: repeated int32 int32 = 2;\n     */\n    int32: number[];\n    /**\n     * @generated from protobuf field: repeated quirks.v1.RepeatedRequest.Enum enum = 3;\n     */\n    enum: RepeatedRequest_Enum[];\n    /**\n     * @generated from protobuf field: repeated lib.Message message = 4;\n     */\n    message: Message[];\n}\n/**\n * @generated from protobuf enum quirks.v1.RepeatedRequest.Enum\n */\nexport enum RepeatedRequest_Enum {\n    /**\n     * @generated from protobuf enum value: KEY_0 = 0;\n     */\n    KEY_0 = 0,\n    /**\n     * @generated from protobuf enum value: KEY_1 = 1;\n     */\n    KEY_1 = 1\n}\n/**\n * @generated from protobuf message quirks.v1.TypesRequest\n */\nexport interface TypesRequest {\n    /**\n     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1;\n     */\n    timestamp?: Timestamp;\n    /**\n     * @generated from protobuf field: bool bool = 2;\n     */\n    bool: boolean;\n}\n/**\n * @generated from protobuf message quirks.v1.Void\n */\nexport interface Void {\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass MapRequest$Type extends MessageType<MapRequest> {\n    constructor() {\n        super(\"quirks.v1.MapRequest\", [\n            { no: 1, name: \"string_string\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"scalar\", T: 9 /*ScalarType.STRING*/ } },\n            { no: 2, name: \"string_int32\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"scalar\", T: 5 /*ScalarType.INT32*/ } },\n            { no: 3, name: \"sint64_string\", kind: \"map\", K: 18 /*ScalarType.SINT64*/, V: { kind: \"scalar\", T: 9 /*ScalarType.STRING*/ } },\n            { no: 4, name: \"string_repeated_string\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"message\", T: () => MapRequest_RepeatedString } }\n        ]);\n    }\n    create(value?: PartialMessage<MapRequest>): MapRequest {\n        const message = { stringString: {}, stringInt32: {}, sint64String: {}, stringRepeatedString: {} };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<MapRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRequest): MapRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* map<string, string> string_string */ 1:\n                    this.binaryReadMap1(message.stringString, reader, options);\n                    break;\n                case /* map<string, int32> string_int32 */ 2:\n                    this.binaryReadMap2(message.stringInt32, reader, options);\n                    break;\n                case /* map<sint64, string> sint64_string */ 3:\n                    this.binaryReadMap3(message.sint64String, reader, options);\n                    break;\n                case /* map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string */ 4:\n                    this.binaryReadMap4(message.stringRepeatedString, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    private binaryReadMap1(map: MapRequest[\"stringString\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringString\"] | undefined, val: MapRequest[\"stringString\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = reader.string();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_string\");\n            }\n        }\n        map[key ?? \"\"] = val ?? \"\";\n    }\n    private binaryReadMap2(map: MapRequest[\"stringInt32\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringInt32\"] | undefined, val: MapRequest[\"stringInt32\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = reader.int32();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_int32\");\n            }\n        }\n        map[key ?? \"\"] = val ?? 0;\n    }\n    private binaryReadMap3(map: MapRequest[\"sint64String\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"sint64String\"] | undefined, val: MapRequest[\"sint64String\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.sint64().toString();\n                    break;\n                case 2:\n                    val = reader.string();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.sint64_string\");\n            }\n        }\n        map[key ?? \"0\"] = val ?? \"\";\n    }\n    private binaryReadMap4(map: MapRequest[\"stringRepeatedString\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringRepeatedString\"] | undefined, val: MapRequest[\"stringRepeatedString\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = MapRequest_RepeatedString.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_repeated_string\");\n            }\n        }\n        map[key ?? \"\"] = val ?? MapRequest_RepeatedString.create();\n    }\n    internalBinaryWrite(message: MapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* map<string, string> string_string = 1; */\n        for (let k of Object.keys(message.stringString))\n            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.stringString[k]).join();\n        /* map<string, int32> string_int32 = 2; */\n        for (let k of Object.keys(message.stringInt32))\n            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.stringInt32[k]).join();\n        /* map<sint64, string> sint64_string = 3; */\n        for (let k of Object.keys(message.sint64String))\n            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.LengthDelimited).string(message.sint64String[k]).join();\n        /* map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string = 4; */\n        for (let k of Object.keys(message.stringRepeatedString)) {\n            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);\n            writer.tag(2, WireType.LengthDelimited).fork();\n            MapRequest_RepeatedString.internalBinaryWrite(message.stringRepeatedString[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.MapRequest\n */\nexport const MapRequest = new MapRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MapRequest_RepeatedString$Type extends MessageType<MapRequest_RepeatedString> {\n    constructor() {\n        super(\"quirks.v1.MapRequest.RepeatedString\", [\n            { no: 1, name: \"value\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<MapRequest_RepeatedString>): MapRequest_RepeatedString {\n        const message = { value: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<MapRequest_RepeatedString>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRequest_RepeatedString): MapRequest_RepeatedString {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated string value */ 1:\n                    message.value.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MapRequest_RepeatedString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated string value = 1; */\n        for (let i = 0; i < message.value.length; i++)\n            writer.tag(1, WireType.LengthDelimited).string(message.value[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.MapRequest.RepeatedString\n */\nexport const MapRequest_RepeatedString = new MapRequest_RepeatedString$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RepeatedRequest$Type extends MessageType<RepeatedRequest> {\n    constructor() {\n        super(\"quirks.v1.RepeatedRequest\", [\n            { no: 1, name: \"string\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"int32\", kind: \"scalar\", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },\n            { no: 3, name: \"enum\", kind: \"enum\", repeat: 1 /*RepeatType.PACKED*/, T: () => [\"quirks.v1.RepeatedRequest.Enum\", RepeatedRequest_Enum] },\n            { no: 4, name: \"message\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }\n        ]);\n    }\n    create(value?: PartialMessage<RepeatedRequest>): RepeatedRequest {\n        const message = { string: [], int32: [], enum: [], message: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<RepeatedRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedRequest): RepeatedRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated string string */ 1:\n                    message.string.push(reader.string());\n                    break;\n                case /* repeated int32 int32 */ 2:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.int32.push(reader.int32());\n                    else\n                        message.int32.push(reader.int32());\n                    break;\n                case /* repeated quirks.v1.RepeatedRequest.Enum enum */ 3:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.enum.push(reader.int32());\n                    else\n                        message.enum.push(reader.int32());\n                    break;\n                case /* repeated lib.Message message */ 4:\n                    message.message.push(Message.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RepeatedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated string string = 1; */\n        for (let i = 0; i < message.string.length; i++)\n            writer.tag(1, WireType.LengthDelimited).string(message.string[i]);\n        /* repeated int32 int32 = 2; */\n        if (message.int32.length) {\n            writer.tag(2, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.int32.length; i++)\n                writer.int32(message.int32[i]);\n            writer.join();\n        }\n        /* repeated quirks.v1.RepeatedRequest.Enum enum = 3; */\n        if (message.enum.length) {\n            writer.tag(3, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.enum.length; i++)\n                writer.int32(message.enum[i]);\n            writer.join();\n        }\n        /* repeated lib.Message message = 4; */\n        for (let i = 0; i < message.message.length; i++)\n            Message.internalBinaryWrite(message.message[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.RepeatedRequest\n */\nexport const RepeatedRequest = new RepeatedRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TypesRequest$Type extends MessageType<TypesRequest> {\n    constructor() {\n        super(\"quirks.v1.TypesRequest\", [\n            { no: 1, name: \"timestamp\", kind: \"message\", T: () => Timestamp },\n            { no: 2, name: \"bool\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TypesRequest>): TypesRequest {\n        const message = { bool: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TypesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypesRequest): TypesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* google.protobuf.Timestamp timestamp */ 1:\n                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);\n                    break;\n                case /* bool bool */ 2:\n                    message.bool = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* google.protobuf.Timestamp timestamp = 1; */\n        if (message.timestamp)\n            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* bool bool = 2; */\n        if (message.bool !== false)\n            writer.tag(2, WireType.Varint).bool(message.bool);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.TypesRequest\n */\nexport const TypesRequest = new TypesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Void$Type extends MessageType<Void> {\n    constructor() {\n        super(\"quirks.v1.Void\", []);\n    }\n    create(value?: PartialMessage<Void>): Void {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Void>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Void): Void {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: Void, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.Void\n */\nexport const Void = new Void$Type();\n/**\n * @generated ServiceType for protobuf service quirks.v1.Quirks\n */\nexport const Quirks = new ServiceType(\"quirks.v1.Quirks\", [\n    { name: \"GetAuthentication\", options: {}, I: Void, O: Message },\n    { name: \"Map\", options: {}, I: MapRequest, O: MapRequest },\n    { name: \"MethodWithAReallyLongNameGmthggupcbmnphflnnvu\", options: {}, I: Void, O: Message },\n    { name: \"Panic\", options: {}, I: Void, O: Message },\n    { name: \"Repeated\", options: {}, I: RepeatedRequest, O: RepeatedRequest },\n    { name: \"Types\", options: {}, I: TypesRequest, O: TypesRequest }\n]);\n" }, { path: "search-service.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"search-service.proto\" (syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { SearchService } from \"./search-service\";\nimport type { IndexResponse } from \"./search-service\";\nimport type { IndexRequest } from \"./search-service\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { SearchResponse } from \"./search-service\";\nimport type { SearchRequest } from \"./search-service\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service SearchService\n */\nexport interface ISearchServiceClient {\n    /**\n     * @generated from protobuf rpc: Search(SearchRequest) returns (SearchResponse);\n     */\n    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse>;\n    /**\n     * @generated from protobuf rpc: Index(IndexRequest) returns (IndexResponse);\n     */\n    index(input: IndexRequest, options?: RpcOptions): UnaryCall<IndexRequest, IndexResponse>;\n}\n/**\n * @generated from protobuf service SearchService\n */\nexport class SearchServiceClient implements ISearchServiceClient, ServiceInfo {\n    typeName = SearchService.typeName;\n    methods = SearchService.methods;\n    options = SearchService.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: Search(SearchRequest) returns (SearchResponse);\n     */\n    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SearchRequest, SearchResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Index(IndexRequest) returns (IndexResponse);\n     */\n    index(input: IndexRequest, options?: RpcOptions): UnaryCall<IndexRequest, IndexResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<IndexRequest, IndexResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "search-service.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"search-service.proto\" (syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message SearchRequest\n */\nexport interface SearchRequest {\n    /**\n     * @generated from protobuf field: string query = 1;\n     */\n    query: string;\n    /**\n     * @generated from protobuf field: int32 page_number = 2;\n     */\n    pageNumber: number;\n    /**\n     * @generated from protobuf field: int32 result_per_page = 3;\n     */\n    resultPerPage: number;\n}\n/**\n * @generated from protobuf message SearchResponse\n */\nexport interface SearchResponse {\n    /**\n     * @generated from protobuf field: repeated Result results = 1;\n     */\n    results: Result[];\n}\n/**\n * @generated from protobuf message Result\n */\nexport interface Result {\n    /**\n     * @generated from protobuf field: string url = 1;\n     */\n    url: string;\n    /**\n     * @generated from protobuf field: string title = 2;\n     */\n    title: string;\n    /**\n     * @generated from protobuf field: repeated string snippets = 3;\n     */\n    snippets: string[];\n    /**\n     * @generated from protobuf field: bool is_ad = 4;\n     */\n    isAd: boolean;\n}\n/**\n * @generated from protobuf message IndexRequest\n */\nexport interface IndexRequest {\n    /**\n     * @generated from protobuf field: Result result = 1;\n     */\n    result?: Result;\n    /**\n     * @generated from protobuf field: Position position = 2;\n     */\n    position: Position;\n    /**\n     * @generated from protobuf field: uint64 additional_copies = 3;\n     */\n    additionalCopies: string;\n}\n/**\n * @generated from protobuf message IndexResponse\n */\nexport interface IndexResponse {\n    /**\n     * @generated from protobuf field: Result result = 1;\n     */\n    result?: Result;\n}\n/**\n * @generated from protobuf enum Position\n */\nexport enum Position {\n    /**\n     * @generated from protobuf enum value: POSITION_TOP = 0;\n     */\n    TOP = 0,\n    /**\n     * @generated from protobuf enum value: POSITION_BOTTOM = 1;\n     */\n    BOTTOM = 1\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass SearchRequest$Type extends MessageType<SearchRequest> {\n    constructor() {\n        super(\"SearchRequest\", [\n            { no: 1, name: \"query\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"page_number\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ },\n            { no: 3, name: \"result_per_page\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    create(value?: PartialMessage<SearchRequest>): SearchRequest {\n        const message = { query: \"\", pageNumber: 0, resultPerPage: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<SearchRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string query */ 1:\n                    message.query = reader.string();\n                    break;\n                case /* int32 page_number */ 2:\n                    message.pageNumber = reader.int32();\n                    break;\n                case /* int32 result_per_page */ 3:\n                    message.resultPerPage = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string query = 1; */\n        if (message.query !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.query);\n        /* int32 page_number = 2; */\n        if (message.pageNumber !== 0)\n            writer.tag(2, WireType.Varint).int32(message.pageNumber);\n        /* int32 result_per_page = 3; */\n        if (message.resultPerPage !== 0)\n            writer.tag(3, WireType.Varint).int32(message.resultPerPage);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message SearchRequest\n */\nexport const SearchRequest = new SearchRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SearchResponse$Type extends MessageType<SearchResponse> {\n    constructor() {\n        super(\"SearchResponse\", [\n            { no: 1, name: \"results\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Result }\n        ]);\n    }\n    create(value?: PartialMessage<SearchResponse>): SearchResponse {\n        const message = { results: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<SearchResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated Result results */ 1:\n                    message.results.push(Result.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated Result results = 1; */\n        for (let i = 0; i < message.results.length; i++)\n            Result.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message SearchResponse\n */\nexport const SearchResponse = new SearchResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Result$Type extends MessageType<Result> {\n    constructor() {\n        super(\"Result\", [\n            { no: 1, name: \"url\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"title\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"snippets\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"is_ad\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Result>): Result {\n        const message = { url: \"\", title: \"\", snippets: [], isAd: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Result>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Result): Result {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string url */ 1:\n                    message.url = reader.string();\n                    break;\n                case /* string title */ 2:\n                    message.title = reader.string();\n                    break;\n                case /* repeated string snippets */ 3:\n                    message.snippets.push(reader.string());\n                    break;\n                case /* bool is_ad */ 4:\n                    message.isAd = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string url = 1; */\n        if (message.url !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.url);\n        /* string title = 2; */\n        if (message.title !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.title);\n        /* repeated string snippets = 3; */\n        for (let i = 0; i < message.snippets.length; i++)\n            writer.tag(3, WireType.LengthDelimited).string(message.snippets[i]);\n        /* bool is_ad = 4; */\n        if (message.isAd !== false)\n            writer.tag(4, WireType.Varint).bool(message.isAd);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message Result\n */\nexport const Result = new Result$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass IndexRequest$Type extends MessageType<IndexRequest> {\n    constructor() {\n        super(\"IndexRequest\", [\n            { no: 1, name: \"result\", kind: \"message\", T: () => Result },\n            { no: 2, name: \"position\", kind: \"enum\", T: () => [\"Position\", Position, \"POSITION_\"] },\n            { no: 3, name: \"additional_copies\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<IndexRequest>): IndexRequest {\n        const message = { position: 0, additionalCopies: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<IndexRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexRequest): IndexRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* Result result */ 1:\n                    message.result = Result.internalBinaryRead(reader, reader.uint32(), options, message.result);\n                    break;\n                case /* Position position */ 2:\n                    message.position = reader.int32();\n                    break;\n                case /* uint64 additional_copies */ 3:\n                    message.additionalCopies = reader.uint64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: IndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* Result result = 1; */\n        if (message.result)\n            Result.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* Position position = 2; */\n        if (message.position !== 0)\n            writer.tag(2, WireType.Varint).int32(message.position);\n        /* uint64 additional_copies = 3; */\n        if (message.additionalCopies !== \"0\")\n            writer.tag(3, WireType.Varint).uint64(message.additionalCopies);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message IndexRequest\n */\nexport const IndexRequest = new IndexRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass IndexResponse$Type extends MessageType<IndexResponse> {\n    constructor() {\n        super(\"IndexResponse\", [\n            { no: 1, name: \"result\", kind: \"message\", T: () => Result }\n        ]);\n    }\n    create(value?: PartialMessage<IndexResponse>): IndexResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<IndexResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexResponse): IndexResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* Result result */ 1:\n                    message.result = Result.internalBinaryRead(reader, reader.uint32(), options, message.result);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: IndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* Result result = 1; */\n        if (message.result)\n            Result.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message IndexResponse\n */\nexport const IndexResponse = new IndexResponse$Type();\n/**\n * @generated ServiceType for protobuf service SearchService\n */\nexport const SearchService = new ServiceType(\"SearchService\", [\n    { name: \"Search\", options: {}, I: SearchRequest, O: SearchResponse },\n    { name: \"Index\", options: {}, I: IndexRequest, O: IndexResponse }\n]);\n" }] };
export function getClient(name: string, transport: RpcTransport): ServiceInfo | undefined { switch (name) {
    case "QuirksClient": return new QuirksClient(transport);
    case "SearchServiceClient": return new SearchServiceClient(transport);
} return undefined; }
