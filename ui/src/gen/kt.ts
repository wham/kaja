import { AdminApiClient } from "./proto/admin-api.client";
import { CostCenterApiClient } from "./proto/cost-center-api.client";
import { CustomerApiClient } from "./proto/customer-api.client";
import { InvoiceAPIClient } from "./proto/invoice-api.client";
import { PricingApiClient } from "./proto/pricing-api.client";
import { ProductApiClient } from "./proto/product-api.client";
import { UsageApiClient } from "./proto/usage-api.client";
import { RpcTransport, ServiceInfo } from "@protobuf-ts/runtime-rpc";
export const model = { gens: [{ path: "../ui/src/gen/.gitignore", content: "**/*.ts" }, { path: "../ui/src/gen/proto/admin-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/admin-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { AdminApi } from \"./admin-api\";\nimport type { GenerateUsageResponse } from \"./admin-api\";\nimport type { GenerateUsageRequest } from \"./admin-api\";\nimport type { TriggerWatermarkWorkflowResponse } from \"./admin-api\";\nimport type { TriggerWatermarkWorkflowRequest } from \"./admin-api\";\nimport type { TriggerInvoiceGenerationResponse } from \"./admin-api\";\nimport type { TriggerInvoiceGenerationRequest } from \"./admin-api\";\nimport type { TriggerAzureEmissionResponse } from \"./admin-api\";\nimport type { TriggerAzureEmissionRequest } from \"./admin-api\";\nimport type { GetAzureEmissionResponse } from \"./admin-api\";\nimport type { GetAzureEmissionRequest } from \"./admin-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { ProcessDeadLetterQueueResponse } from \"./admin-api\";\nimport type { ProcessDeadLetterQueueRequest } from \"./admin-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.AdminApi\n */\nexport interface IAdminApiClient {\n    /**\n     * @generated from protobuf rpc: ProcessDeadLetterQueue(billing_platform.api.v1.ProcessDeadLetterQueueRequest) returns (billing_platform.api.v1.ProcessDeadLetterQueueResponse);\n     */\n    processDeadLetterQueue(input: ProcessDeadLetterQueueRequest, options?: RpcOptions): UnaryCall<ProcessDeadLetterQueueRequest, ProcessDeadLetterQueueResponse>;\n    /**\n     * @generated from protobuf rpc: GetAzureEmission(billing_platform.api.v1.GetAzureEmissionRequest) returns (billing_platform.api.v1.GetAzureEmissionResponse);\n     */\n    getAzureEmission(input: GetAzureEmissionRequest, options?: RpcOptions): UnaryCall<GetAzureEmissionRequest, GetAzureEmissionResponse>;\n    /**\n     * @generated from protobuf rpc: TriggerAzureEmission(billing_platform.api.v1.TriggerAzureEmissionRequest) returns (billing_platform.api.v1.TriggerAzureEmissionResponse);\n     */\n    triggerAzureEmission(input: TriggerAzureEmissionRequest, options?: RpcOptions): UnaryCall<TriggerAzureEmissionRequest, TriggerAzureEmissionResponse>;\n    /**\n     * @generated from protobuf rpc: TriggerInvoiceGeneration(billing_platform.api.v1.TriggerInvoiceGenerationRequest) returns (billing_platform.api.v1.TriggerInvoiceGenerationResponse);\n     */\n    triggerInvoiceGeneration(input: TriggerInvoiceGenerationRequest, options?: RpcOptions): UnaryCall<TriggerInvoiceGenerationRequest, TriggerInvoiceGenerationResponse>;\n    /**\n     * @generated from protobuf rpc: TriggerWatermarkWorkflow(billing_platform.api.v1.TriggerWatermarkWorkflowRequest) returns (billing_platform.api.v1.TriggerWatermarkWorkflowResponse);\n     */\n    triggerWatermarkWorkflow(input: TriggerWatermarkWorkflowRequest, options?: RpcOptions): UnaryCall<TriggerWatermarkWorkflowRequest, TriggerWatermarkWorkflowResponse>;\n    /**\n     * @generated from protobuf rpc: GenerateUsage(billing_platform.api.v1.GenerateUsageRequest) returns (billing_platform.api.v1.GenerateUsageResponse);\n     */\n    generateUsage(input: GenerateUsageRequest, options?: RpcOptions): UnaryCall<GenerateUsageRequest, GenerateUsageResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.AdminApi\n */\nexport class AdminApiClient implements IAdminApiClient, ServiceInfo {\n    typeName = AdminApi.typeName;\n    methods = AdminApi.methods;\n    options = AdminApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: ProcessDeadLetterQueue(billing_platform.api.v1.ProcessDeadLetterQueueRequest) returns (billing_platform.api.v1.ProcessDeadLetterQueueResponse);\n     */\n    processDeadLetterQueue(input: ProcessDeadLetterQueueRequest, options?: RpcOptions): UnaryCall<ProcessDeadLetterQueueRequest, ProcessDeadLetterQueueResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<ProcessDeadLetterQueueRequest, ProcessDeadLetterQueueResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAzureEmission(billing_platform.api.v1.GetAzureEmissionRequest) returns (billing_platform.api.v1.GetAzureEmissionResponse);\n     */\n    getAzureEmission(input: GetAzureEmissionRequest, options?: RpcOptions): UnaryCall<GetAzureEmissionRequest, GetAzureEmissionResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAzureEmissionRequest, GetAzureEmissionResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: TriggerAzureEmission(billing_platform.api.v1.TriggerAzureEmissionRequest) returns (billing_platform.api.v1.TriggerAzureEmissionResponse);\n     */\n    triggerAzureEmission(input: TriggerAzureEmissionRequest, options?: RpcOptions): UnaryCall<TriggerAzureEmissionRequest, TriggerAzureEmissionResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<TriggerAzureEmissionRequest, TriggerAzureEmissionResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: TriggerInvoiceGeneration(billing_platform.api.v1.TriggerInvoiceGenerationRequest) returns (billing_platform.api.v1.TriggerInvoiceGenerationResponse);\n     */\n    triggerInvoiceGeneration(input: TriggerInvoiceGenerationRequest, options?: RpcOptions): UnaryCall<TriggerInvoiceGenerationRequest, TriggerInvoiceGenerationResponse> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<TriggerInvoiceGenerationRequest, TriggerInvoiceGenerationResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: TriggerWatermarkWorkflow(billing_platform.api.v1.TriggerWatermarkWorkflowRequest) returns (billing_platform.api.v1.TriggerWatermarkWorkflowResponse);\n     */\n    triggerWatermarkWorkflow(input: TriggerWatermarkWorkflowRequest, options?: RpcOptions): UnaryCall<TriggerWatermarkWorkflowRequest, TriggerWatermarkWorkflowResponse> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<TriggerWatermarkWorkflowRequest, TriggerWatermarkWorkflowResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GenerateUsage(billing_platform.api.v1.GenerateUsageRequest) returns (billing_platform.api.v1.GenerateUsageResponse);\n     */\n    generateUsage(input: GenerateUsageRequest, options?: RpcOptions): UnaryCall<GenerateUsageRequest, GenerateUsageResponse> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GenerateUsageRequest, GenerateUsageResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/admin-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/admin-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message billing_platform.api.v1.ProcessDeadLetterQueueRequest\n */\nexport interface ProcessDeadLetterQueueRequest {\n    /**\n     * @generated from protobuf field: int64 num = 1;\n     */\n    num: string;\n    /**\n     * @generated from protobuf field: string queueName = 2;\n     */\n    queueName: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.ProcessDeadLetterQueueResponse\n */\nexport interface ProcessDeadLetterQueueResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAzureEmissionRequest\n */\nexport interface GetAzureEmissionRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: int64 year = 3;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 4;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: int64 day = 5;\n     */\n    day: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAzureEmissionResponse\n */\nexport interface GetAzureEmissionResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.AzureEmission azureEmission = 1;\n     */\n    azureEmission?: AzureEmission;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.AzureEmission\n */\nexport interface AzureEmission {\n    /**\n     * @generated from protobuf field: string azurePartitionKey = 1;\n     */\n    azurePartitionKey: string;\n    /**\n     * @generated from protobuf field: string meterId = 2;\n     */\n    meterId: string;\n    /**\n     * @generated from protobuf field: string subscriptionId = 3;\n     */\n    subscriptionId: string;\n    /**\n     * @generated from protobuf field: double quantity = 4;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.AzureEmissionStatus status = 5;\n     */\n    status: AzureEmissionStatus;\n    /**\n     * @generated from protobuf field: string errorMessage = 6;\n     */\n    errorMessage: string;\n    /**\n     * @generated from protobuf field: double GrossQuantity = 7 [json_name = \"GrossQuantity\"];\n     */\n    grossQuantity: number;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerAzureEmissionRequest\n */\nexport interface TriggerAzureEmissionRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: int64 day = 4;\n     */\n    day: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerAzureEmissionResponse\n */\nexport interface TriggerAzureEmissionResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerInvoiceGenerationRequest\n */\nexport interface TriggerInvoiceGenerationRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerInvoiceGenerationResponse\n */\nexport interface TriggerInvoiceGenerationResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerWatermarkWorkflowRequest\n */\nexport interface TriggerWatermarkWorkflowRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: int64 year = 3;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 4;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: int64 day = 5;\n     */\n    day: string;\n    /**\n     * @generated from protobuf field: int64 hour = 6;\n     */\n    hour: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.TriggerWatermarkWorkflowResponse\n */\nexport interface TriggerWatermarkWorkflowResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GenerateUsageRequest\n */\nexport interface GenerateUsageRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: int64 orgId = 3;\n     */\n    orgId: string;\n    /**\n     * @generated from protobuf field: int64 repoId = 4;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: float amount = 5;\n     */\n    amount: number;\n    /**\n     * @generated from protobuf field: float quantity = 6;\n     */\n    quantity: number;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GenerateUsageResponse\n */\nexport interface GenerateUsageResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.AzureEmissionStatus\n */\nexport enum AzureEmissionStatus {\n    /**\n     * @generated from protobuf enum value: New = 0;\n     */\n    New = 0,\n    /**\n     * @generated from protobuf enum value: Recorded = 1;\n     */\n    Recorded = 1,\n    /**\n     * @generated from protobuf enum value: Completed = 2;\n     */\n    Completed = 2,\n    /**\n     * @generated from protobuf enum value: Failed = 3;\n     */\n    Failed = 3,\n    /**\n     * @generated from protobuf enum value: Ignored = 4;\n     */\n    Ignored = 4\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass ProcessDeadLetterQueueRequest$Type extends MessageType<ProcessDeadLetterQueueRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.ProcessDeadLetterQueueRequest\", [\n            { no: 1, name: \"num\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 2, name: \"queueName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<ProcessDeadLetterQueueRequest>): ProcessDeadLetterQueueRequest {\n        const message = { num: \"0\", queueName: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<ProcessDeadLetterQueueRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessDeadLetterQueueRequest): ProcessDeadLetterQueueRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int64 num */ 1:\n                    message.num = reader.int64().toString();\n                    break;\n                case /* string queueName */ 2:\n                    message.queueName = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ProcessDeadLetterQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int64 num = 1; */\n        if (message.num !== \"0\")\n            writer.tag(1, WireType.Varint).int64(message.num);\n        /* string queueName = 2; */\n        if (message.queueName !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.queueName);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.ProcessDeadLetterQueueRequest\n */\nexport const ProcessDeadLetterQueueRequest = new ProcessDeadLetterQueueRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ProcessDeadLetterQueueResponse$Type extends MessageType<ProcessDeadLetterQueueResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.ProcessDeadLetterQueueResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<ProcessDeadLetterQueueResponse>): ProcessDeadLetterQueueResponse {\n        const message = { success: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<ProcessDeadLetterQueueResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessDeadLetterQueueResponse): ProcessDeadLetterQueueResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ProcessDeadLetterQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.ProcessDeadLetterQueueResponse\n */\nexport const ProcessDeadLetterQueueResponse = new ProcessDeadLetterQueueResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAzureEmissionRequest$Type extends MessageType<GetAzureEmissionRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAzureEmissionRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"day\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetAzureEmissionRequest>): GetAzureEmissionRequest {\n        const message = { customerId: \"\", sku: \"\", year: \"0\", month: \"0\", day: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAzureEmissionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAzureEmissionRequest): GetAzureEmissionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* int64 year */ 3:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 4:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* int64 day */ 5:\n                    message.day = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAzureEmissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* int64 year = 3; */\n        if (message.year !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.year);\n        /* int64 month = 4; */\n        if (message.month !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.month);\n        /* int64 day = 5; */\n        if (message.day !== \"0\")\n            writer.tag(5, WireType.Varint).int64(message.day);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAzureEmissionRequest\n */\nexport const GetAzureEmissionRequest = new GetAzureEmissionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAzureEmissionResponse$Type extends MessageType<GetAzureEmissionResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAzureEmissionResponse\", [\n            { no: 1, name: \"azureEmission\", kind: \"message\", T: () => AzureEmission }\n        ]);\n    }\n    create(value?: PartialMessage<GetAzureEmissionResponse>): GetAzureEmissionResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAzureEmissionResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAzureEmissionResponse): GetAzureEmissionResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.AzureEmission azureEmission */ 1:\n                    message.azureEmission = AzureEmission.internalBinaryRead(reader, reader.uint32(), options, message.azureEmission);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAzureEmissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.AzureEmission azureEmission = 1; */\n        if (message.azureEmission)\n            AzureEmission.internalBinaryWrite(message.azureEmission, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAzureEmissionResponse\n */\nexport const GetAzureEmissionResponse = new GetAzureEmissionResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AzureEmission$Type extends MessageType<AzureEmission> {\n    constructor() {\n        super(\"billing_platform.api.v1.AzureEmission\", [\n            { no: 1, name: \"azurePartitionKey\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"meterId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"subscriptionId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"status\", kind: \"enum\", T: () => [\"billing_platform.api.v1.AzureEmissionStatus\", AzureEmissionStatus] },\n            { no: 6, name: \"errorMessage\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 7, name: \"GrossQuantity\", kind: \"scalar\", jsonName: \"GrossQuantity\", T: 1 /*ScalarType.DOUBLE*/ }\n        ]);\n    }\n    create(value?: PartialMessage<AzureEmission>): AzureEmission {\n        const message = { azurePartitionKey: \"\", meterId: \"\", subscriptionId: \"\", quantity: 0, status: 0, errorMessage: \"\", grossQuantity: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<AzureEmission>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureEmission): AzureEmission {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string azurePartitionKey */ 1:\n                    message.azurePartitionKey = reader.string();\n                    break;\n                case /* string meterId */ 2:\n                    message.meterId = reader.string();\n                    break;\n                case /* string subscriptionId */ 3:\n                    message.subscriptionId = reader.string();\n                    break;\n                case /* double quantity */ 4:\n                    message.quantity = reader.double();\n                    break;\n                case /* billing_platform.api.v1.AzureEmissionStatus status */ 5:\n                    message.status = reader.int32();\n                    break;\n                case /* string errorMessage */ 6:\n                    message.errorMessage = reader.string();\n                    break;\n                case /* double GrossQuantity = 7 [json_name = \"GrossQuantity\"];*/ 7:\n                    message.grossQuantity = reader.double();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: AzureEmission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string azurePartitionKey = 1; */\n        if (message.azurePartitionKey !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.azurePartitionKey);\n        /* string meterId = 2; */\n        if (message.meterId !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.meterId);\n        /* string subscriptionId = 3; */\n        if (message.subscriptionId !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.subscriptionId);\n        /* double quantity = 4; */\n        if (message.quantity !== 0)\n            writer.tag(4, WireType.Bit64).double(message.quantity);\n        /* billing_platform.api.v1.AzureEmissionStatus status = 5; */\n        if (message.status !== 0)\n            writer.tag(5, WireType.Varint).int32(message.status);\n        /* string errorMessage = 6; */\n        if (message.errorMessage !== \"\")\n            writer.tag(6, WireType.LengthDelimited).string(message.errorMessage);\n        /* double GrossQuantity = 7 [json_name = \"GrossQuantity\"]; */\n        if (message.grossQuantity !== 0)\n            writer.tag(7, WireType.Bit64).double(message.grossQuantity);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.AzureEmission\n */\nexport const AzureEmission = new AzureEmission$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerAzureEmissionRequest$Type extends MessageType<TriggerAzureEmissionRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerAzureEmissionRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"day\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerAzureEmissionRequest>): TriggerAzureEmissionRequest {\n        const message = { customerId: \"\", year: \"0\", month: \"0\", day: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerAzureEmissionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerAzureEmissionRequest): TriggerAzureEmissionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* int64 day */ 4:\n                    message.day = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerAzureEmissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        /* int64 day = 4; */\n        if (message.day !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.day);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerAzureEmissionRequest\n */\nexport const TriggerAzureEmissionRequest = new TriggerAzureEmissionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerAzureEmissionResponse$Type extends MessageType<TriggerAzureEmissionResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerAzureEmissionResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerAzureEmissionResponse>): TriggerAzureEmissionResponse {\n        const message = { success: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerAzureEmissionResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerAzureEmissionResponse): TriggerAzureEmissionResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerAzureEmissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerAzureEmissionResponse\n */\nexport const TriggerAzureEmissionResponse = new TriggerAzureEmissionResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerInvoiceGenerationRequest$Type extends MessageType<TriggerInvoiceGenerationRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerInvoiceGenerationRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerInvoiceGenerationRequest>): TriggerInvoiceGenerationRequest {\n        const message = { customerId: \"\", year: \"0\", month: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerInvoiceGenerationRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerInvoiceGenerationRequest): TriggerInvoiceGenerationRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerInvoiceGenerationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerInvoiceGenerationRequest\n */\nexport const TriggerInvoiceGenerationRequest = new TriggerInvoiceGenerationRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerInvoiceGenerationResponse$Type extends MessageType<TriggerInvoiceGenerationResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerInvoiceGenerationResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerInvoiceGenerationResponse>): TriggerInvoiceGenerationResponse {\n        const message = { success: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerInvoiceGenerationResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerInvoiceGenerationResponse): TriggerInvoiceGenerationResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerInvoiceGenerationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerInvoiceGenerationResponse\n */\nexport const TriggerInvoiceGenerationResponse = new TriggerInvoiceGenerationResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerWatermarkWorkflowRequest$Type extends MessageType<TriggerWatermarkWorkflowRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerWatermarkWorkflowRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"day\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 6, name: \"hour\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerWatermarkWorkflowRequest>): TriggerWatermarkWorkflowRequest {\n        const message = { customerId: \"\", sku: \"\", year: \"0\", month: \"0\", day: \"0\", hour: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerWatermarkWorkflowRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerWatermarkWorkflowRequest): TriggerWatermarkWorkflowRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* int64 year */ 3:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 4:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* int64 day */ 5:\n                    message.day = reader.int64().toString();\n                    break;\n                case /* int64 hour */ 6:\n                    message.hour = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerWatermarkWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* int64 year = 3; */\n        if (message.year !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.year);\n        /* int64 month = 4; */\n        if (message.month !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.month);\n        /* int64 day = 5; */\n        if (message.day !== \"0\")\n            writer.tag(5, WireType.Varint).int64(message.day);\n        /* int64 hour = 6; */\n        if (message.hour !== \"0\")\n            writer.tag(6, WireType.Varint).int64(message.hour);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerWatermarkWorkflowRequest\n */\nexport const TriggerWatermarkWorkflowRequest = new TriggerWatermarkWorkflowRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TriggerWatermarkWorkflowResponse$Type extends MessageType<TriggerWatermarkWorkflowResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.TriggerWatermarkWorkflowResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TriggerWatermarkWorkflowResponse>): TriggerWatermarkWorkflowResponse {\n        const message = { success: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TriggerWatermarkWorkflowResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerWatermarkWorkflowResponse): TriggerWatermarkWorkflowResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TriggerWatermarkWorkflowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.TriggerWatermarkWorkflowResponse\n */\nexport const TriggerWatermarkWorkflowResponse = new TriggerWatermarkWorkflowResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GenerateUsageRequest$Type extends MessageType<GenerateUsageRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GenerateUsageRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"orgId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"amount\", kind: \"scalar\", T: 2 /*ScalarType.FLOAT*/ },\n            { no: 6, name: \"quantity\", kind: \"scalar\", T: 2 /*ScalarType.FLOAT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GenerateUsageRequest>): GenerateUsageRequest {\n        const message = { customerId: \"\", sku: \"\", orgId: \"0\", repoId: \"0\", amount: 0, quantity: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GenerateUsageRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateUsageRequest): GenerateUsageRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* int64 orgId */ 3:\n                    message.orgId = reader.int64().toString();\n                    break;\n                case /* int64 repoId */ 4:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* float amount */ 5:\n                    message.amount = reader.float();\n                    break;\n                case /* float quantity */ 6:\n                    message.quantity = reader.float();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GenerateUsageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* int64 orgId = 3; */\n        if (message.orgId !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.orgId);\n        /* int64 repoId = 4; */\n        if (message.repoId !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.repoId);\n        /* float amount = 5; */\n        if (message.amount !== 0)\n            writer.tag(5, WireType.Bit32).float(message.amount);\n        /* float quantity = 6; */\n        if (message.quantity !== 0)\n            writer.tag(6, WireType.Bit32).float(message.quantity);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GenerateUsageRequest\n */\nexport const GenerateUsageRequest = new GenerateUsageRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GenerateUsageResponse$Type extends MessageType<GenerateUsageResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GenerateUsageResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GenerateUsageResponse>): GenerateUsageResponse {\n        const message = { success: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GenerateUsageResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateUsageResponse): GenerateUsageResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GenerateUsageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GenerateUsageResponse\n */\nexport const GenerateUsageResponse = new GenerateUsageResponse$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.AdminApi\n */\nexport const AdminApi = new ServiceType(\"billing_platform.api.v1.AdminApi\", [\n    { name: \"ProcessDeadLetterQueue\", options: {}, I: ProcessDeadLetterQueueRequest, O: ProcessDeadLetterQueueResponse },\n    { name: \"GetAzureEmission\", options: {}, I: GetAzureEmissionRequest, O: GetAzureEmissionResponse },\n    { name: \"TriggerAzureEmission\", options: {}, I: TriggerAzureEmissionRequest, O: TriggerAzureEmissionResponse },\n    { name: \"TriggerInvoiceGeneration\", options: {}, I: TriggerInvoiceGenerationRequest, O: TriggerInvoiceGenerationResponse },\n    { name: \"TriggerWatermarkWorkflow\", options: {}, I: TriggerWatermarkWorkflowRequest, O: TriggerWatermarkWorkflowResponse },\n    { name: \"GenerateUsage\", options: {}, I: GenerateUsageRequest, O: GenerateUsageResponse }\n]);\n" }, { path: "../ui/src/gen/proto/base.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/base.proto\" (package \"billing_platform.base\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message billing_platform.base.EntityDetail\n */\nexport interface EntityDetail {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 ownerId = 2;\n     */\n    ownerId: string;\n    /**\n     * @generated from protobuf field: int64 repoId = 3;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: int64 actorId = 4;\n     */\n    actorId: string;\n}\n/**\n * @generated from protobuf message billing_platform.base.Key\n */\nexport interface Key {\n    /**\n     * @generated from protobuf field: string id = 1;\n     */\n    id: string;\n    /**\n     * @generated from protobuf field: string partitionKey = 2;\n     */\n    partitionKey: string;\n}\n/**\n * @generated from protobuf enum billing_platform.base.BillingPeriod\n */\nexport enum BillingPeriod {\n    /**\n     * @generated from protobuf enum value: Unspecified = 0;\n     */\n    Unspecified = 0,\n    /**\n     * @generated from protobuf enum value: Hourly = 1;\n     */\n    Hourly = 1,\n    /**\n     * @generated from protobuf enum value: Daily = 2;\n     */\n    Daily = 2,\n    /**\n     * @generated from protobuf enum value: Monthly = 3;\n     */\n    Monthly = 3,\n    /**\n     * @generated from protobuf enum value: Yearly = 4;\n     */\n    Yearly = 4\n}\n/**\n * @generated from protobuf enum billing_platform.base.ResourceType\n */\nexport enum ResourceType {\n    /**\n     * @generated from protobuf enum value: NoTarget = 0;\n     */\n    NoTarget = 0,\n    /**\n     * @generated from protobuf enum value: User = 1;\n     */\n    User = 1,\n    /**\n     * @generated from protobuf enum value: Team = 2;\n     */\n    Team = 2,\n    /**\n     * @generated from protobuf enum value: Repo = 3;\n     */\n    Repo = 3,\n    /**\n     * @generated from protobuf enum value: Org = 4;\n     */\n    Org = 4,\n    /**\n     * @generated from protobuf enum value: Enterprise = 5;\n     */\n    Enterprise = 5,\n    /**\n     * @generated from protobuf enum value: CostCenterResource = 6;\n     */\n    CostCenterResource = 6,\n    /**\n     * @generated from protobuf enum value: CustomerResource = 7;\n     */\n    CustomerResource = 7\n}\n/**\n * @generated from protobuf enum billing_platform.base.UsageGroupBy\n */\nexport enum UsageGroupBy {\n    /**\n     * @generated from protobuf enum value: NoGroupBy = 0;\n     */\n    NoGroupBy = 0,\n    /**\n     * @generated from protobuf enum value: GroupByProduct = 1;\n     */\n    GroupByProduct = 1,\n    /**\n     * @generated from protobuf enum value: GroupBySku = 2;\n     */\n    GroupBySku = 2,\n    /**\n     * @generated from protobuf enum value: GroupByOrganization = 3;\n     */\n    GroupByOrganization = 3,\n    /**\n     * @generated from protobuf enum value: GroupByRepository = 4;\n     */\n    GroupByRepository = 4,\n    /**\n     * @generated from protobuf enum value: GroupByOrgRepoProductSku = 5;\n     */\n    GroupByOrgRepoProductSku = 5\n}\n/**\n * @generated from protobuf enum billing_platform.base.UnitType\n */\nexport enum UnitType {\n    /**\n     * @generated from protobuf enum value: Unknown = 0;\n     */\n    Unknown = 0,\n    /**\n     * @generated from protobuf enum value: Seconds = 1;\n     */\n    Seconds = 1,\n    /**\n     * 1 minute = 60 seconds\n     *\n     * @generated from protobuf enum value: Minutes = 2;\n     */\n    Minutes = 2,\n    /**\n     * 1 hour = 3600 seconds\n     *\n     * @generated from protobuf enum value: Hours = 3;\n     */\n    Hours = 3,\n    /**\n     * @generated from protobuf enum value: Bytes = 4;\n     */\n    Bytes = 4,\n    /**\n     * 1 megabyte = 1024^2 bytes\n     *\n     * @generated from protobuf enum value: Megabytes = 5;\n     */\n    Megabytes = 5,\n    /**\n     * 1 gigabyte = 1024^3 bytes\n     *\n     * @generated from protobuf enum value: Gigabytes = 6;\n     */\n    Gigabytes = 6,\n    /**\n     * 1 byte hour = 1 byte * 1 hour\n     *\n     * @generated from protobuf enum value: ByteHours = 7;\n     */\n    ByteHours = 7,\n    /**\n     * 1 megabyte hour = 1024^2 bytehours\n     *\n     * @generated from protobuf enum value: MegabyteHours = 8;\n     */\n    MegabyteHours = 8,\n    /**\n     * 1 gigabyte hour = 1024^3 bytehours\n     *\n     * @generated from protobuf enum value: GigabyteHours = 9;\n     */\n    GigabyteHours = 9,\n    /**\n     * 1 gigabyte month = 1024^3 bytehours * 24 * 31\n     *\n     * @generated from protobuf enum value: GigabyteMonths = 10;\n     */\n    GigabyteMonths = 10,\n    /**\n     * @generated from protobuf enum value: UserMonths = 11;\n     */\n    UserMonths = 11\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass EntityDetail$Type extends MessageType<EntityDetail> {\n    constructor() {\n        super(\"billing_platform.base.EntityDetail\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"ownerId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"actorId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<EntityDetail>): EntityDetail {\n        const message = { customerId: \"\", ownerId: \"0\", repoId: \"0\", actorId: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<EntityDetail>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityDetail): EntityDetail {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 ownerId */ 2:\n                    message.ownerId = reader.int64().toString();\n                    break;\n                case /* int64 repoId */ 3:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* int64 actorId */ 4:\n                    message.actorId = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: EntityDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 ownerId = 2; */\n        if (message.ownerId !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.ownerId);\n        /* int64 repoId = 3; */\n        if (message.repoId !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.repoId);\n        /* int64 actorId = 4; */\n        if (message.actorId !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.actorId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.base.EntityDetail\n */\nexport const EntityDetail = new EntityDetail$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Key$Type extends MessageType<Key> {\n    constructor() {\n        super(\"billing_platform.base.Key\", [\n            { no: 1, name: \"id\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"partitionKey\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Key>): Key {\n        const message = { id: \"\", partitionKey: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Key>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Key): Key {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string id */ 1:\n                    message.id = reader.string();\n                    break;\n                case /* string partitionKey */ 2:\n                    message.partitionKey = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Key, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string id = 1; */\n        if (message.id !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.id);\n        /* string partitionKey = 2; */\n        if (message.partitionKey !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.partitionKey);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.base.Key\n */\nexport const Key = new Key$Type();\n" }, { path: "../ui/src/gen/proto/cost-center-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/cost-center-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { CostCenterApi } from \"./cost-center-api\";\nimport type { FindCostCenterForResponse } from \"./cost-center-api\";\nimport type { FindCostCenterForRequest } from \"./cost-center-api\";\nimport type { AddResourceToCostCenterResponse } from \"./cost-center-api\";\nimport type { AddResourceToCostCenterRequest } from \"./cost-center-api\";\nimport type { GetCostCenterResponse } from \"./cost-center-api\";\nimport type { GetCostCenterRequest } from \"./cost-center-api\";\nimport type { GetAllCostCentersResponse } from \"./cost-center-api\";\nimport type { GetAllCostCentersRequest } from \"./cost-center-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { UpsertCostCenterResponse } from \"./cost-center-api\";\nimport type { UpsertCostCenterRequest } from \"./cost-center-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.CostCenterApi\n */\nexport interface ICostCenterApiClient {\n    /**\n     * @generated from protobuf rpc: UpsertCostCenter(billing_platform.api.v1.UpsertCostCenterRequest) returns (billing_platform.api.v1.UpsertCostCenterResponse);\n     */\n    upsertCostCenter(input: UpsertCostCenterRequest, options?: RpcOptions): UnaryCall<UpsertCostCenterRequest, UpsertCostCenterResponse>;\n    /**\n     * @generated from protobuf rpc: GetAllCostCenters(billing_platform.api.v1.GetAllCostCentersRequest) returns (billing_platform.api.v1.GetAllCostCentersResponse);\n     */\n    getAllCostCenters(input: GetAllCostCentersRequest, options?: RpcOptions): UnaryCall<GetAllCostCentersRequest, GetAllCostCentersResponse>;\n    /**\n     * @generated from protobuf rpc: GetCostCenter(billing_platform.api.v1.GetCostCenterRequest) returns (billing_platform.api.v1.GetCostCenterResponse);\n     */\n    getCostCenter(input: GetCostCenterRequest, options?: RpcOptions): UnaryCall<GetCostCenterRequest, GetCostCenterResponse>;\n    /**\n     * @generated from protobuf rpc: AddResourceTo(billing_platform.api.v1.AddResourceToCostCenterRequest) returns (billing_platform.api.v1.AddResourceToCostCenterResponse);\n     */\n    addResourceTo(input: AddResourceToCostCenterRequest, options?: RpcOptions): UnaryCall<AddResourceToCostCenterRequest, AddResourceToCostCenterResponse>;\n    /**\n     * @generated from protobuf rpc: FindFor(billing_platform.api.v1.FindCostCenterForRequest) returns (billing_platform.api.v1.FindCostCenterForResponse);\n     */\n    findFor(input: FindCostCenterForRequest, options?: RpcOptions): UnaryCall<FindCostCenterForRequest, FindCostCenterForResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.CostCenterApi\n */\nexport class CostCenterApiClient implements ICostCenterApiClient, ServiceInfo {\n    typeName = CostCenterApi.typeName;\n    methods = CostCenterApi.methods;\n    options = CostCenterApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: UpsertCostCenter(billing_platform.api.v1.UpsertCostCenterRequest) returns (billing_platform.api.v1.UpsertCostCenterResponse);\n     */\n    upsertCostCenter(input: UpsertCostCenterRequest, options?: RpcOptions): UnaryCall<UpsertCostCenterRequest, UpsertCostCenterResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpsertCostCenterRequest, UpsertCostCenterResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAllCostCenters(billing_platform.api.v1.GetAllCostCentersRequest) returns (billing_platform.api.v1.GetAllCostCentersResponse);\n     */\n    getAllCostCenters(input: GetAllCostCentersRequest, options?: RpcOptions): UnaryCall<GetAllCostCentersRequest, GetAllCostCentersResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllCostCentersRequest, GetAllCostCentersResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetCostCenter(billing_platform.api.v1.GetCostCenterRequest) returns (billing_platform.api.v1.GetCostCenterResponse);\n     */\n    getCostCenter(input: GetCostCenterRequest, options?: RpcOptions): UnaryCall<GetCostCenterRequest, GetCostCenterResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetCostCenterRequest, GetCostCenterResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: AddResourceTo(billing_platform.api.v1.AddResourceToCostCenterRequest) returns (billing_platform.api.v1.AddResourceToCostCenterResponse);\n     */\n    addResourceTo(input: AddResourceToCostCenterRequest, options?: RpcOptions): UnaryCall<AddResourceToCostCenterRequest, AddResourceToCostCenterResponse> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<AddResourceToCostCenterRequest, AddResourceToCostCenterResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: FindFor(billing_platform.api.v1.FindCostCenterForRequest) returns (billing_platform.api.v1.FindCostCenterForResponse);\n     */\n    findFor(input: FindCostCenterForRequest, options?: RpcOptions): UnaryCall<FindCostCenterForRequest, FindCostCenterForResponse> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<FindCostCenterForRequest, FindCostCenterForResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/cost-center-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/cost-center-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { ResourceType } from \"./base\";\nimport { EntityDetail } from \"./base\";\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllCostCentersRequest\n */\nexport interface GetAllCostCentersRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllCostCentersResponse\n */\nexport interface GetAllCostCentersResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.CostCenter costCenters = 1;\n     */\n    costCenters: CostCenter[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertCostCenterRequest\n */\nexport interface UpsertCostCenterRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenter costCenter = 1;\n     */\n    costCenter?: CostCenter;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertCostCenterResponse\n */\nexport interface UpsertCostCenterResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterKey costCenterKey = 1;\n     */\n    costCenterKey?: CostCenterKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCostCenterRequest\n */\nexport interface GetCostCenterRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterKey costCenterKey = 1;\n     */\n    costCenterKey?: CostCenterKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCostCenterResponse\n */\nexport interface GetCostCenterResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenter costCenter = 1;\n     */\n    costCenter?: CostCenter;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.AddResourceToCostCenterRequest\n */\nexport interface AddResourceToCostCenterRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterKey key = 1;\n     */\n    key?: CostCenterKey;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Resource resource = 2;\n     */\n    resource?: Resource;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.AddResourceToCostCenterResponse\n */\nexport interface AddResourceToCostCenterResponse {\n    /**\n     * @generated from protobuf field: bool success = 1;\n     */\n    success: boolean;\n    /**\n     * @generated from protobuf field: string message = 2;\n     */\n    message: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.FindCostCenterForRequest\n */\nexport interface FindCostCenterForRequest {\n    /**\n     * @generated from protobuf field: billing_platform.base.EntityDetail entityDetail = 1;\n     */\n    entityDetail?: EntityDetail;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.FindCostCenterForResponse\n */\nexport interface FindCostCenterForResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterKey costCenterKey = 1;\n     */\n    costCenterKey?: CostCenterKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CostCenter\n */\nexport interface CostCenter {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterKey costCenterKey = 2;\n     */\n    costCenterKey?: CostCenterKey;\n    /**\n     * @generated from protobuf field: string name = 3;\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Resource resources = 4;\n     */\n    resources: Resource[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CostCenterKey\n */\nexport interface CostCenterKey {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.CostCenterType targetType = 2;\n     */\n    targetType: CostCenterType;\n    /**\n     * @generated from protobuf field: string targetId = 3;\n     */\n    targetId: string;\n    /**\n     * @generated from protobuf field: string uuid = 4;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Resource\n */\nexport interface Resource {\n    /**\n     * @generated from protobuf field: string id = 2;\n     */\n    id: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.ResourceType type = 3;\n     */\n    type: ResourceType;\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.CostCenterType\n */\nexport enum CostCenterType {\n    /**\n     * @generated from protobuf enum value: NoCostCenter = 0;\n     */\n    NoCostCenter = 0,\n    /**\n     * @generated from protobuf enum value: GitHubEnterpriseCustomer = 1;\n     */\n    GitHubEnterpriseCustomer = 1,\n    /**\n     * @generated from protobuf enum value: ZuoraSubscription = 2;\n     */\n    ZuoraSubscription = 2,\n    /**\n     * @generated from protobuf enum value: CreditCard = 3;\n     */\n    CreditCard = 3,\n    /**\n     * @generated from protobuf enum value: AzureSubscription = 4;\n     */\n    AzureSubscription = 4\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllCostCentersRequest$Type extends MessageType<GetAllCostCentersRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllCostCentersRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllCostCentersRequest>): GetAllCostCentersRequest {\n        const message = { customerId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllCostCentersRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllCostCentersRequest): GetAllCostCentersRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllCostCentersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllCostCentersRequest\n */\nexport const GetAllCostCentersRequest = new GetAllCostCentersRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllCostCentersResponse$Type extends MessageType<GetAllCostCentersResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllCostCentersResponse\", [\n            { no: 1, name: \"costCenters\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => CostCenter }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllCostCentersResponse>): GetAllCostCentersResponse {\n        const message = { costCenters: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllCostCentersResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllCostCentersResponse): GetAllCostCentersResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.CostCenter costCenters */ 1:\n                    message.costCenters.push(CostCenter.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllCostCentersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.CostCenter costCenters = 1; */\n        for (let i = 0; i < message.costCenters.length; i++)\n            CostCenter.internalBinaryWrite(message.costCenters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllCostCentersResponse\n */\nexport const GetAllCostCentersResponse = new GetAllCostCentersResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertCostCenterRequest$Type extends MessageType<UpsertCostCenterRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertCostCenterRequest\", [\n            { no: 1, name: \"costCenter\", kind: \"message\", T: () => CostCenter }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertCostCenterRequest>): UpsertCostCenterRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertCostCenterRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertCostCenterRequest): UpsertCostCenterRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenter costCenter */ 1:\n                    message.costCenter = CostCenter.internalBinaryRead(reader, reader.uint32(), options, message.costCenter);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertCostCenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenter costCenter = 1; */\n        if (message.costCenter)\n            CostCenter.internalBinaryWrite(message.costCenter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertCostCenterRequest\n */\nexport const UpsertCostCenterRequest = new UpsertCostCenterRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertCostCenterResponse$Type extends MessageType<UpsertCostCenterResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertCostCenterResponse\", [\n            { no: 1, name: \"costCenterKey\", kind: \"message\", T: () => CostCenterKey }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertCostCenterResponse>): UpsertCostCenterResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertCostCenterResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertCostCenterResponse): UpsertCostCenterResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenterKey costCenterKey */ 1:\n                    message.costCenterKey = CostCenterKey.internalBinaryRead(reader, reader.uint32(), options, message.costCenterKey);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertCostCenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenterKey costCenterKey = 1; */\n        if (message.costCenterKey)\n            CostCenterKey.internalBinaryWrite(message.costCenterKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertCostCenterResponse\n */\nexport const UpsertCostCenterResponse = new UpsertCostCenterResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCostCenterRequest$Type extends MessageType<GetCostCenterRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCostCenterRequest\", [\n            { no: 1, name: \"costCenterKey\", kind: \"message\", T: () => CostCenterKey }\n        ]);\n    }\n    create(value?: PartialMessage<GetCostCenterRequest>): GetCostCenterRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCostCenterRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCostCenterRequest): GetCostCenterRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenterKey costCenterKey */ 1:\n                    message.costCenterKey = CostCenterKey.internalBinaryRead(reader, reader.uint32(), options, message.costCenterKey);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCostCenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenterKey costCenterKey = 1; */\n        if (message.costCenterKey)\n            CostCenterKey.internalBinaryWrite(message.costCenterKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCostCenterRequest\n */\nexport const GetCostCenterRequest = new GetCostCenterRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCostCenterResponse$Type extends MessageType<GetCostCenterResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCostCenterResponse\", [\n            { no: 1, name: \"costCenter\", kind: \"message\", T: () => CostCenter }\n        ]);\n    }\n    create(value?: PartialMessage<GetCostCenterResponse>): GetCostCenterResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCostCenterResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCostCenterResponse): GetCostCenterResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenter costCenter */ 1:\n                    message.costCenter = CostCenter.internalBinaryRead(reader, reader.uint32(), options, message.costCenter);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCostCenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenter costCenter = 1; */\n        if (message.costCenter)\n            CostCenter.internalBinaryWrite(message.costCenter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCostCenterResponse\n */\nexport const GetCostCenterResponse = new GetCostCenterResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AddResourceToCostCenterRequest$Type extends MessageType<AddResourceToCostCenterRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.AddResourceToCostCenterRequest\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => CostCenterKey },\n            { no: 2, name: \"resource\", kind: \"message\", T: () => Resource }\n        ]);\n    }\n    create(value?: PartialMessage<AddResourceToCostCenterRequest>): AddResourceToCostCenterRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<AddResourceToCostCenterRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddResourceToCostCenterRequest): AddResourceToCostCenterRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenterKey key */ 1:\n                    message.key = CostCenterKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                case /* billing_platform.api.v1.Resource resource */ 2:\n                    message.resource = Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: AddResourceToCostCenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenterKey key = 1; */\n        if (message.key)\n            CostCenterKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* billing_platform.api.v1.Resource resource = 2; */\n        if (message.resource)\n            Resource.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.AddResourceToCostCenterRequest\n */\nexport const AddResourceToCostCenterRequest = new AddResourceToCostCenterRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AddResourceToCostCenterResponse$Type extends MessageType<AddResourceToCostCenterResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.AddResourceToCostCenterResponse\", [\n            { no: 1, name: \"success\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 2, name: \"message\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<AddResourceToCostCenterResponse>): AddResourceToCostCenterResponse {\n        const message = { success: false, message: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<AddResourceToCostCenterResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddResourceToCostCenterResponse): AddResourceToCostCenterResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool success */ 1:\n                    message.success = reader.bool();\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: AddResourceToCostCenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool success = 1; */\n        if (message.success !== false)\n            writer.tag(1, WireType.Varint).bool(message.success);\n        /* string message = 2; */\n        if (message.message !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.AddResourceToCostCenterResponse\n */\nexport const AddResourceToCostCenterResponse = new AddResourceToCostCenterResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FindCostCenterForRequest$Type extends MessageType<FindCostCenterForRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.FindCostCenterForRequest\", [\n            { no: 1, name: \"entityDetail\", kind: \"message\", T: () => EntityDetail }\n        ]);\n    }\n    create(value?: PartialMessage<FindCostCenterForRequest>): FindCostCenterForRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<FindCostCenterForRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindCostCenterForRequest): FindCostCenterForRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.base.EntityDetail entityDetail */ 1:\n                    message.entityDetail = EntityDetail.internalBinaryRead(reader, reader.uint32(), options, message.entityDetail);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: FindCostCenterForRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.base.EntityDetail entityDetail = 1; */\n        if (message.entityDetail)\n            EntityDetail.internalBinaryWrite(message.entityDetail, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.FindCostCenterForRequest\n */\nexport const FindCostCenterForRequest = new FindCostCenterForRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FindCostCenterForResponse$Type extends MessageType<FindCostCenterForResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.FindCostCenterForResponse\", [\n            { no: 1, name: \"costCenterKey\", kind: \"message\", T: () => CostCenterKey }\n        ]);\n    }\n    create(value?: PartialMessage<FindCostCenterForResponse>): FindCostCenterForResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<FindCostCenterForResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindCostCenterForResponse): FindCostCenterForResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenterKey costCenterKey */ 1:\n                    message.costCenterKey = CostCenterKey.internalBinaryRead(reader, reader.uint32(), options, message.costCenterKey);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: FindCostCenterForResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenterKey costCenterKey = 1; */\n        if (message.costCenterKey)\n            CostCenterKey.internalBinaryWrite(message.costCenterKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.FindCostCenterForResponse\n */\nexport const FindCostCenterForResponse = new FindCostCenterForResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CostCenter$Type extends MessageType<CostCenter> {\n    constructor() {\n        super(\"billing_platform.api.v1.CostCenter\", [\n            { no: 2, name: \"costCenterKey\", kind: \"message\", T: () => CostCenterKey },\n            { no: 3, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"resources\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Resource }\n        ]);\n    }\n    create(value?: PartialMessage<CostCenter>): CostCenter {\n        const message = { name: \"\", resources: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CostCenter>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CostCenter): CostCenter {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.CostCenterKey costCenterKey */ 2:\n                    message.costCenterKey = CostCenterKey.internalBinaryRead(reader, reader.uint32(), options, message.costCenterKey);\n                    break;\n                case /* string name */ 3:\n                    message.name = reader.string();\n                    break;\n                case /* repeated billing_platform.api.v1.Resource resources */ 4:\n                    message.resources.push(Resource.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CostCenter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.CostCenterKey costCenterKey = 2; */\n        if (message.costCenterKey)\n            CostCenterKey.internalBinaryWrite(message.costCenterKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* string name = 3; */\n        if (message.name !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.name);\n        /* repeated billing_platform.api.v1.Resource resources = 4; */\n        for (let i = 0; i < message.resources.length; i++)\n            Resource.internalBinaryWrite(message.resources[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CostCenter\n */\nexport const CostCenter = new CostCenter$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CostCenterKey$Type extends MessageType<CostCenterKey> {\n    constructor() {\n        super(\"billing_platform.api.v1.CostCenterKey\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"targetType\", kind: \"enum\", T: () => [\"billing_platform.api.v1.CostCenterType\", CostCenterType] },\n            { no: 3, name: \"targetId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<CostCenterKey>): CostCenterKey {\n        const message = { customerId: \"\", targetType: 0, targetId: \"\", uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CostCenterKey>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CostCenterKey): CostCenterKey {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* billing_platform.api.v1.CostCenterType targetType */ 2:\n                    message.targetType = reader.int32();\n                    break;\n                case /* string targetId */ 3:\n                    message.targetId = reader.string();\n                    break;\n                case /* string uuid */ 4:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CostCenterKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* billing_platform.api.v1.CostCenterType targetType = 2; */\n        if (message.targetType !== 0)\n            writer.tag(2, WireType.Varint).int32(message.targetType);\n        /* string targetId = 3; */\n        if (message.targetId !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.targetId);\n        /* string uuid = 4; */\n        if (message.uuid !== \"\")\n            writer.tag(4, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CostCenterKey\n */\nexport const CostCenterKey = new CostCenterKey$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Resource$Type extends MessageType<Resource> {\n    constructor() {\n        super(\"billing_platform.api.v1.Resource\", [\n            { no: 2, name: \"id\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"type\", kind: \"enum\", T: () => [\"billing_platform.base.ResourceType\", ResourceType] }\n        ]);\n    }\n    create(value?: PartialMessage<Resource>): Resource {\n        const message = { id: \"\", type: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Resource>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resource): Resource {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string id */ 2:\n                    message.id = reader.string();\n                    break;\n                case /* billing_platform.base.ResourceType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Resource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string id = 2; */\n        if (message.id !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.id);\n        /* billing_platform.base.ResourceType type = 3; */\n        if (message.type !== 0)\n            writer.tag(3, WireType.Varint).int32(message.type);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Resource\n */\nexport const Resource = new Resource$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.CostCenterApi\n */\nexport const CostCenterApi = new ServiceType(\"billing_platform.api.v1.CostCenterApi\", [\n    { name: \"UpsertCostCenter\", options: {}, I: UpsertCostCenterRequest, O: UpsertCostCenterResponse },\n    { name: \"GetAllCostCenters\", options: {}, I: GetAllCostCentersRequest, O: GetAllCostCentersResponse },\n    { name: \"GetCostCenter\", options: {}, I: GetCostCenterRequest, O: GetCostCenterResponse },\n    { name: \"AddResourceTo\", options: {}, I: AddResourceToCostCenterRequest, O: AddResourceToCostCenterResponse },\n    { name: \"FindFor\", options: {}, I: FindCostCenterForRequest, O: FindCostCenterForResponse }\n]);\n" }, { path: "../ui/src/gen/proto/customer-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/customer-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { CustomerApi } from \"./customer-api\";\nimport type { GetAllDiscountStatesResponse } from \"./customer-api\";\nimport type { GetAllDiscountStatesRequest } from \"./customer-api\";\nimport type { GetDiscountStateResponse } from \"./customer-api\";\nimport type { GetDiscountStateRequest } from \"./customer-api\";\nimport type { CreateDiscountResponse } from \"./customer-api\";\nimport type { CreateDiscountRequest } from \"./customer-api\";\nimport type { GetAllDiscountsResponse } from \"./customer-api\";\nimport type { GetAllDiscountsRequest } from \"./customer-api\";\nimport type { GetDiscountResponse } from \"./customer-api\";\nimport type { GetDiscountRequest } from \"./customer-api\";\nimport type { CanProceedWithUsageResponse } from \"./customer-api\";\nimport type { CanProceedWithUsageRequest } from \"./customer-api\";\nimport type { GetBudgetStateResponse } from \"./customer-api\";\nimport type { GetBudgetStateRequest } from \"./customer-api\";\nimport type { GetAllBudgetsResponse } from \"./customer-api\";\nimport type { GetAllBudgetsRequest } from \"./customer-api\";\nimport type { DeleteBudgetResponse } from \"./customer-api\";\nimport type { DeleteBudgetRequest } from \"./customer-api\";\nimport type { GetBudgetByUuidResponse } from \"./customer-api\";\nimport type { GetBudgetByUuidRequest } from \"./customer-api\";\nimport type { GetBudgetResponse } from \"./customer-api\";\nimport type { GetBudgetRequest } from \"./customer-api\";\nimport type { UpsertBudgetResponse } from \"./customer-api\";\nimport type { UpsertBudgetRequest } from \"./customer-api\";\nimport type { GetCustomersResponse } from \"./customer-api\";\nimport type { GetCustomersRequest } from \"./customer-api\";\nimport type { GetCustomerResponse } from \"./customer-api\";\nimport type { GetCustomerRequest } from \"./customer-api\";\nimport type { PatchCustomerResponse } from \"./customer-api\";\nimport type { PatchCustomerRequest } from \"./customer-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { CreateCustomerResponse } from \"./customer-api\";\nimport type { CreateCustomerRequest } from \"./customer-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.CustomerApi\n */\nexport interface ICustomerApiClient {\n    /**\n     * @generated from protobuf rpc: UpsertCustomer(billing_platform.api.v1.CreateCustomerRequest) returns (billing_platform.api.v1.CreateCustomerResponse);\n     */\n    upsertCustomer(input: CreateCustomerRequest, options?: RpcOptions): UnaryCall<CreateCustomerRequest, CreateCustomerResponse>;\n    /**\n     * @generated from protobuf rpc: PatchCustomer(billing_platform.api.v1.PatchCustomerRequest) returns (billing_platform.api.v1.PatchCustomerResponse);\n     */\n    patchCustomer(input: PatchCustomerRequest, options?: RpcOptions): UnaryCall<PatchCustomerRequest, PatchCustomerResponse>;\n    /**\n     * @generated from protobuf rpc: GetCustomer(billing_platform.api.v1.GetCustomerRequest) returns (billing_platform.api.v1.GetCustomerResponse);\n     */\n    getCustomer(input: GetCustomerRequest, options?: RpcOptions): UnaryCall<GetCustomerRequest, GetCustomerResponse>;\n    /**\n     * @generated from protobuf rpc: GetCustomers(billing_platform.api.v1.GetCustomersRequest) returns (billing_platform.api.v1.GetCustomersResponse);\n     */\n    getCustomers(input: GetCustomersRequest, options?: RpcOptions): UnaryCall<GetCustomersRequest, GetCustomersResponse>;\n    /**\n     * @generated from protobuf rpc: UpsertBudget(billing_platform.api.v1.UpsertBudgetRequest) returns (billing_platform.api.v1.UpsertBudgetResponse);\n     */\n    upsertBudget(input: UpsertBudgetRequest, options?: RpcOptions): UnaryCall<UpsertBudgetRequest, UpsertBudgetResponse>;\n    /**\n     * @generated from protobuf rpc: GetBudget(billing_platform.api.v1.GetBudgetRequest) returns (billing_platform.api.v1.GetBudgetResponse);\n     */\n    getBudget(input: GetBudgetRequest, options?: RpcOptions): UnaryCall<GetBudgetRequest, GetBudgetResponse>;\n    /**\n     * @generated from protobuf rpc: GetBudgetByUuid(billing_platform.api.v1.GetBudgetByUuidRequest) returns (billing_platform.api.v1.GetBudgetByUuidResponse);\n     */\n    getBudgetByUuid(input: GetBudgetByUuidRequest, options?: RpcOptions): UnaryCall<GetBudgetByUuidRequest, GetBudgetByUuidResponse>;\n    /**\n     * @generated from protobuf rpc: DeleteBudget(billing_platform.api.v1.DeleteBudgetRequest) returns (billing_platform.api.v1.DeleteBudgetResponse);\n     */\n    deleteBudget(input: DeleteBudgetRequest, options?: RpcOptions): UnaryCall<DeleteBudgetRequest, DeleteBudgetResponse>;\n    /**\n     * @generated from protobuf rpc: GetAllBudgets(billing_platform.api.v1.GetAllBudgetsRequest) returns (billing_platform.api.v1.GetAllBudgetsResponse);\n     */\n    getAllBudgets(input: GetAllBudgetsRequest, options?: RpcOptions): UnaryCall<GetAllBudgetsRequest, GetAllBudgetsResponse>;\n    /**\n     * @generated from protobuf rpc: GetBudgetState(billing_platform.api.v1.GetBudgetStateRequest) returns (billing_platform.api.v1.GetBudgetStateResponse);\n     */\n    getBudgetState(input: GetBudgetStateRequest, options?: RpcOptions): UnaryCall<GetBudgetStateRequest, GetBudgetStateResponse>;\n    /**\n     * @generated from protobuf rpc: CanProceedWithUsage(billing_platform.api.v1.CanProceedWithUsageRequest) returns (billing_platform.api.v1.CanProceedWithUsageResponse);\n     */\n    canProceedWithUsage(input: CanProceedWithUsageRequest, options?: RpcOptions): UnaryCall<CanProceedWithUsageRequest, CanProceedWithUsageResponse>;\n    /**\n     * @generated from protobuf rpc: GetDiscount(billing_platform.api.v1.GetDiscountRequest) returns (billing_platform.api.v1.GetDiscountResponse);\n     */\n    getDiscount(input: GetDiscountRequest, options?: RpcOptions): UnaryCall<GetDiscountRequest, GetDiscountResponse>;\n    /**\n     * @generated from protobuf rpc: GetAllDiscounts(billing_platform.api.v1.GetAllDiscountsRequest) returns (billing_platform.api.v1.GetAllDiscountsResponse);\n     */\n    getAllDiscounts(input: GetAllDiscountsRequest, options?: RpcOptions): UnaryCall<GetAllDiscountsRequest, GetAllDiscountsResponse>;\n    /**\n     * @generated from protobuf rpc: CreateDiscount(billing_platform.api.v1.CreateDiscountRequest) returns (billing_platform.api.v1.CreateDiscountResponse);\n     */\n    createDiscount(input: CreateDiscountRequest, options?: RpcOptions): UnaryCall<CreateDiscountRequest, CreateDiscountResponse>;\n    /**\n     * @generated from protobuf rpc: GetDiscountState(billing_platform.api.v1.GetDiscountStateRequest) returns (billing_platform.api.v1.GetDiscountStateResponse);\n     */\n    getDiscountState(input: GetDiscountStateRequest, options?: RpcOptions): UnaryCall<GetDiscountStateRequest, GetDiscountStateResponse>;\n    /**\n     * @generated from protobuf rpc: GetAllDiscountStates(billing_platform.api.v1.GetAllDiscountStatesRequest) returns (billing_platform.api.v1.GetAllDiscountStatesResponse);\n     */\n    getAllDiscountStates(input: GetAllDiscountStatesRequest, options?: RpcOptions): UnaryCall<GetAllDiscountStatesRequest, GetAllDiscountStatesResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.CustomerApi\n */\nexport class CustomerApiClient implements ICustomerApiClient, ServiceInfo {\n    typeName = CustomerApi.typeName;\n    methods = CustomerApi.methods;\n    options = CustomerApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: UpsertCustomer(billing_platform.api.v1.CreateCustomerRequest) returns (billing_platform.api.v1.CreateCustomerResponse);\n     */\n    upsertCustomer(input: CreateCustomerRequest, options?: RpcOptions): UnaryCall<CreateCustomerRequest, CreateCustomerResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<CreateCustomerRequest, CreateCustomerResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: PatchCustomer(billing_platform.api.v1.PatchCustomerRequest) returns (billing_platform.api.v1.PatchCustomerResponse);\n     */\n    patchCustomer(input: PatchCustomerRequest, options?: RpcOptions): UnaryCall<PatchCustomerRequest, PatchCustomerResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PatchCustomerRequest, PatchCustomerResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetCustomer(billing_platform.api.v1.GetCustomerRequest) returns (billing_platform.api.v1.GetCustomerResponse);\n     */\n    getCustomer(input: GetCustomerRequest, options?: RpcOptions): UnaryCall<GetCustomerRequest, GetCustomerResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetCustomerRequest, GetCustomerResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetCustomers(billing_platform.api.v1.GetCustomersRequest) returns (billing_platform.api.v1.GetCustomersResponse);\n     */\n    getCustomers(input: GetCustomersRequest, options?: RpcOptions): UnaryCall<GetCustomersRequest, GetCustomersResponse> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetCustomersRequest, GetCustomersResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpsertBudget(billing_platform.api.v1.UpsertBudgetRequest) returns (billing_platform.api.v1.UpsertBudgetResponse);\n     */\n    upsertBudget(input: UpsertBudgetRequest, options?: RpcOptions): UnaryCall<UpsertBudgetRequest, UpsertBudgetResponse> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpsertBudgetRequest, UpsertBudgetResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetBudget(billing_platform.api.v1.GetBudgetRequest) returns (billing_platform.api.v1.GetBudgetResponse);\n     */\n    getBudget(input: GetBudgetRequest, options?: RpcOptions): UnaryCall<GetBudgetRequest, GetBudgetResponse> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetBudgetRequest, GetBudgetResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetBudgetByUuid(billing_platform.api.v1.GetBudgetByUuidRequest) returns (billing_platform.api.v1.GetBudgetByUuidResponse);\n     */\n    getBudgetByUuid(input: GetBudgetByUuidRequest, options?: RpcOptions): UnaryCall<GetBudgetByUuidRequest, GetBudgetByUuidResponse> {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetBudgetByUuidRequest, GetBudgetByUuidResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: DeleteBudget(billing_platform.api.v1.DeleteBudgetRequest) returns (billing_platform.api.v1.DeleteBudgetResponse);\n     */\n    deleteBudget(input: DeleteBudgetRequest, options?: RpcOptions): UnaryCall<DeleteBudgetRequest, DeleteBudgetResponse> {\n        const method = this.methods[7], opt = this._transport.mergeOptions(options);\n        return stackIntercept<DeleteBudgetRequest, DeleteBudgetResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAllBudgets(billing_platform.api.v1.GetAllBudgetsRequest) returns (billing_platform.api.v1.GetAllBudgetsResponse);\n     */\n    getAllBudgets(input: GetAllBudgetsRequest, options?: RpcOptions): UnaryCall<GetAllBudgetsRequest, GetAllBudgetsResponse> {\n        const method = this.methods[8], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllBudgetsRequest, GetAllBudgetsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetBudgetState(billing_platform.api.v1.GetBudgetStateRequest) returns (billing_platform.api.v1.GetBudgetStateResponse);\n     */\n    getBudgetState(input: GetBudgetStateRequest, options?: RpcOptions): UnaryCall<GetBudgetStateRequest, GetBudgetStateResponse> {\n        const method = this.methods[9], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetBudgetStateRequest, GetBudgetStateResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: CanProceedWithUsage(billing_platform.api.v1.CanProceedWithUsageRequest) returns (billing_platform.api.v1.CanProceedWithUsageResponse);\n     */\n    canProceedWithUsage(input: CanProceedWithUsageRequest, options?: RpcOptions): UnaryCall<CanProceedWithUsageRequest, CanProceedWithUsageResponse> {\n        const method = this.methods[10], opt = this._transport.mergeOptions(options);\n        return stackIntercept<CanProceedWithUsageRequest, CanProceedWithUsageResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetDiscount(billing_platform.api.v1.GetDiscountRequest) returns (billing_platform.api.v1.GetDiscountResponse);\n     */\n    getDiscount(input: GetDiscountRequest, options?: RpcOptions): UnaryCall<GetDiscountRequest, GetDiscountResponse> {\n        const method = this.methods[11], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetDiscountRequest, GetDiscountResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAllDiscounts(billing_platform.api.v1.GetAllDiscountsRequest) returns (billing_platform.api.v1.GetAllDiscountsResponse);\n     */\n    getAllDiscounts(input: GetAllDiscountsRequest, options?: RpcOptions): UnaryCall<GetAllDiscountsRequest, GetAllDiscountsResponse> {\n        const method = this.methods[12], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllDiscountsRequest, GetAllDiscountsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: CreateDiscount(billing_platform.api.v1.CreateDiscountRequest) returns (billing_platform.api.v1.CreateDiscountResponse);\n     */\n    createDiscount(input: CreateDiscountRequest, options?: RpcOptions): UnaryCall<CreateDiscountRequest, CreateDiscountResponse> {\n        const method = this.methods[13], opt = this._transport.mergeOptions(options);\n        return stackIntercept<CreateDiscountRequest, CreateDiscountResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetDiscountState(billing_platform.api.v1.GetDiscountStateRequest) returns (billing_platform.api.v1.GetDiscountStateResponse);\n     */\n    getDiscountState(input: GetDiscountStateRequest, options?: RpcOptions): UnaryCall<GetDiscountStateRequest, GetDiscountStateResponse> {\n        const method = this.methods[14], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetDiscountStateRequest, GetDiscountStateResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAllDiscountStates(billing_platform.api.v1.GetAllDiscountStatesRequest) returns (billing_platform.api.v1.GetAllDiscountStatesResponse);\n     */\n    getAllDiscountStates(input: GetAllDiscountStatesRequest, options?: RpcOptions): UnaryCall<GetAllDiscountStatesRequest, GetAllDiscountStatesResponse> {\n        const method = this.methods[15], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllDiscountStatesRequest, GetAllDiscountStatesResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/customer-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/customer-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { EntityDetail } from \"./base\";\nimport { ResourceType } from \"./base\";\n/**\n * @generated from protobuf message billing_platform.api.v1.CreateCustomerRequest\n */\nexport interface CreateCustomerRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Customer customer = 1;\n     */\n    customer?: Customer;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CreateCustomerResponse\n */\nexport interface CreateCustomerResponse {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.PatchCustomerRequest\n */\nexport interface PatchCustomerRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Customer customer = 1;\n     */\n    customer?: Customer;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.PatchCustomerResponse\n */\nexport interface PatchCustomerResponse {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCustomerRequest\n */\nexport interface GetCustomerRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCustomerResponse\n */\nexport interface GetCustomerResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Customer customer = 1;\n     */\n    customer?: Customer;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCustomersRequest\n */\nexport interface GetCustomersRequest {\n    /**\n     * @generated from protobuf field: repeated string customerIds = 1;\n     */\n    customerIds: string[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetCustomersResponse\n */\nexport interface GetCustomersResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Customer customers = 1;\n     */\n    customers: Customer[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertBudgetRequest\n */\nexport interface UpsertBudgetRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Budget budget = 1;\n     */\n    budget?: Budget;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertBudgetResponse\n */\nexport interface UpsertBudgetResponse {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DeleteBudgetRequest\n */\nexport interface DeleteBudgetRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string uuid = 2;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DeleteBudgetResponse\n */\nexport interface DeleteBudgetResponse {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetRequest\n */\nexport interface GetBudgetRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetKey key = 1;\n     */\n    key?: BudgetKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetResponse\n */\nexport interface GetBudgetResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Budget budget = 1;\n     */\n    budget?: Budget;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetByUuidRequest\n */\nexport interface GetBudgetByUuidRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string uuid = 2;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetByUuidResponse\n */\nexport interface GetBudgetByUuidResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Budget budget = 1;\n     */\n    budget?: Budget;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllBudgetsRequest\n */\nexport interface GetAllBudgetsRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllBudgetsResponse\n */\nexport interface GetAllBudgetsResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.BudgetInfo budgets = 1;\n     */\n    budgets: BudgetInfo[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BudgetInfo\n */\nexport interface BudgetInfo {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Budget budget = 1;\n     */\n    budget?: Budget;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetState budgetState = 2;\n     */\n    budgetState?: BudgetState;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetStateRequest\n */\nexport interface GetBudgetStateRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetKey key = 1;\n     */\n    key?: BudgetKey;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetBudgetStateResponse\n */\nexport interface GetBudgetStateResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetState budgetState = 1;\n     */\n    budgetState?: BudgetState;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CanProceedWithUsageRequest\n */\nexport interface CanProceedWithUsageRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.UsageKey usageKey = 1;\n     */\n    usageKey?: UsageKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CanProceedWithUsageResponse\n */\nexport interface CanProceedWithUsageResponse {\n    /**\n     * @generated from protobuf field: bool canProceed = 1;\n     */\n    canProceed: boolean;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.CanProceedWithUsageInfo applicableBudgets = 2;\n     */\n    applicableBudgets: CanProceedWithUsageInfo[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllDiscountsRequest\n */\nexport interface GetAllDiscountsRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllDiscountStatesRequest\n */\nexport interface GetAllDiscountStatesRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllDiscountsResponse\n */\nexport interface GetAllDiscountsResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Discount discounts = 1;\n     */\n    discounts: Discount[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllDiscountStatesResponse\n */\nexport interface GetAllDiscountStatesResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.DiscountState discounts = 1;\n     */\n    discounts: DiscountState[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountRequest\n */\nexport interface GetDiscountRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.DiscountKey key = 1;\n     */\n    key?: DiscountKey;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountResponse\n */\nexport interface GetDiscountResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Discount discount = 1;\n     */\n    discount?: Discount;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CreateDiscountRequest\n */\nexport interface CreateDiscountRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Discount discount = 1;\n     */\n    discount?: Discount;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CreateDiscountResponse\n */\nexport interface CreateDiscountResponse {\n    /**\n     * @generated from protobuf field: string uuid = 1;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountStateRequest\n */\nexport interface GetDiscountStateRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.DiscountKey key = 1;\n     */\n    key?: DiscountKey;\n    /**\n     * @generated from protobuf field: int64 year = 3;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 4;\n     */\n    month: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountStateResponse\n */\nexport interface GetDiscountStateResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.DiscountState discountState = 1;\n     */\n    discountState?: DiscountState;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Customer\n */\nexport interface Customer {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string CostCenterUUID = 2 [json_name = \"CostCenterUUID\"];\n     */\n    costCenterUUID: string;\n    /**\n     * @generated from protobuf field: bool IsCostCenterProxy = 3 [json_name = \"IsCostCenterProxy\"];\n     */\n    isCostCenterProxy: boolean;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BillingTarget billingTarget = 4;\n     */\n    billingTarget: BillingTarget;\n    /**\n     * @generated from protobuf field: string azureAccountId = 5;\n     */\n    azureAccountId: string;\n    /**\n     * @generated from protobuf field: string zuoraAccountId = 6;\n     */\n    zuoraAccountId: string;\n    /**\n     * @generated from protobuf field: string enterpriseCustomerId = 7;\n     */\n    enterpriseCustomerId: string;\n    /**\n     * @generated from protobuf field: bool enableUsageEmission = 8;\n     */\n    enableUsageEmission: boolean;\n    /**\n     * @generated from protobuf field: string zuoraAccountNumber = 9;\n     */\n    zuoraAccountNumber: string;\n    /**\n     * @generated from protobuf field: string discountPlanName = 10;\n     */\n    discountPlanName: string;\n    /**\n     * @generated from protobuf field: bool billForPublicRepoUsage = 11;\n     */\n    billForPublicRepoUsage: boolean;\n    /**\n     * @generated from protobuf field: int64 effectiveAt = 12;\n     */\n    effectiveAt: string;\n    /**\n     * @generated from protobuf field: repeated string enabledProducts = 13;\n     */\n    enabledProducts: string[];\n    /**\n     * @generated from protobuf field: bool hasPaymentMethod = 14;\n     */\n    hasPaymentMethod: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Budget\n */\nexport interface Budget {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetKey key = 1;\n     */\n    key?: BudgetKey;\n    /**\n     * @generated from protobuf field: double targetAmount = 2;\n     */\n    targetAmount: number;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetLimitType budgetLimitType = 3;\n     */\n    budgetLimitType: BudgetLimitType;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetAlerting budgetAlerting = 4;\n     */\n    budgetAlerting?: BudgetAlerting;\n    /**\n     * @generated from protobuf field: string uuid = 5;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BudgetKey\n */\nexport interface BudgetKey {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.ResourceType targetType = 2;\n     */\n    targetType: ResourceType;\n    /**\n     * @generated from protobuf field: string targetId = 3;\n     */\n    targetId: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.PricingTargetType pricingTargetType = 4;\n     */\n    pricingTargetType: PricingTargetType;\n    /**\n     * @generated from protobuf field: string pricingTargetId = 5;\n     */\n    pricingTargetId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BudgetState\n */\nexport interface BudgetState {\n    /**\n     * @generated from protobuf field: bool isFullyFunded = 1;\n     */\n    isFullyFunded: boolean;\n    /**\n     * @generated from protobuf field: double currentAmount = 2;\n     */\n    currentAmount: number;\n    /**\n     * @generated from protobuf field: double targetAmount = 3;\n     */\n    targetAmount: number;\n    /**\n     * @generated from protobuf field: double quantity = 4;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetThreshold thresholdMet = 5;\n     */\n    thresholdMet?: BudgetThreshold;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BudgetAlerting\n */\nexport interface BudgetAlerting {\n    /**\n     * @generated from protobuf field: bool willAlert = 1;\n     */\n    willAlert: boolean;\n    /**\n     * @generated from protobuf field: repeated string recipientUserIds = 2;\n     */\n    recipientUserIds: string[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BudgetThreshold\n */\nexport interface BudgetThreshold {\n    /**\n     * @generated from protobuf field: string name = 1;\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: double minimumUsagePercentage = 2;\n     */\n    minimumUsagePercentage: number;\n    /**\n     * @generated from protobuf field: bool alertable = 3;\n     */\n    alertable: boolean;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.CanProceedWithUsageInfo\n */\nexport interface CanProceedWithUsageInfo {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetKey budgetKey = 1;\n     */\n    budgetKey?: BudgetKey;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetState budgetState = 2;\n     */\n    budgetState?: BudgetState;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.BudgetLimitType budgetLimitType = 3;\n     */\n    budgetLimitType: BudgetLimitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UsageKey\n */\nexport interface UsageKey {\n    /**\n     * @generated from protobuf field: string sku = 1;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: string product = 2;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: int64 usageAt = 4;\n     */\n    usageAt: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.EntityDetail entityDetail = 5;\n     */\n    entityDetail?: EntityDetail;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Discount\n */\nexport interface Discount {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.DiscountTarget targets = 2;\n     */\n    targets: DiscountTarget[];\n    /**\n     * @generated from protobuf field: double percentage = 3;\n     */\n    percentage: number;\n    /**\n     * @generated from protobuf field: double targetAmount = 4;\n     */\n    targetAmount: number;\n    /**\n     * @generated from protobuf field: string uuid = 5;\n     */\n    uuid: string;\n    /**\n     * @generated from protobuf field: int64 startDate = 6;\n     */\n    startDate: string;\n    /**\n     * @generated from protobuf field: int64 endDate = 7;\n     */\n    endDate: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DiscountKey\n */\nexport interface DiscountKey {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: string uuid = 2;\n     */\n    uuid: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DiscountTarget\n */\nexport interface DiscountTarget {\n    /**\n     * @generated from protobuf field: string id = 1;\n     */\n    id: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.DiscountTargetType type = 2;\n     */\n    type: DiscountTargetType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DiscountState\n */\nexport interface DiscountState {\n    /**\n     * @generated from protobuf field: bool isFullyApplied = 1;\n     */\n    isFullyApplied: boolean;\n    /**\n     * @generated from protobuf field: double currentAmount = 2;\n     */\n    currentAmount: number;\n    /**\n     * @generated from protobuf field: double targetAmount = 3;\n     */\n    targetAmount: number;\n    /**\n     * @generated from protobuf field: double percentage = 4;\n     */\n    percentage: number;\n    /**\n     * @generated from protobuf field: string uuid = 5;\n     */\n    uuid: string;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.DiscountTarget targets = 6;\n     */\n    targets: DiscountTarget[];\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.PricingTargetType\n */\nexport enum PricingTargetType {\n    /**\n     * @generated from protobuf enum value: NoPricingTarget = 0;\n     */\n    NoPricingTarget = 0,\n    /**\n     * @generated from protobuf enum value: ProductPricing = 1;\n     */\n    ProductPricing = 1,\n    /**\n     * @generated from protobuf enum value: SkuPricing = 2;\n     */\n    SkuPricing = 2\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.BudgetLimitType\n */\nexport enum BudgetLimitType {\n    /**\n     * @generated from protobuf enum value: IgnoreLimit = 0;\n     */\n    IgnoreLimit = 0,\n    /**\n     * @generated from protobuf enum value: AlertingOnly = 1;\n     */\n    AlertingOnly = 1,\n    /**\n     * @generated from protobuf enum value: PreventFurtherUsage = 2;\n     */\n    PreventFurtherUsage = 2,\n    /**\n     * @generated from protobuf enum value: StopActiveUsage = 3;\n     */\n    StopActiveUsage = 3\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.BillingTarget\n */\nexport enum BillingTarget {\n    /**\n     * @generated from protobuf enum value: NoBillingTarget = 0;\n     */\n    NoBillingTarget = 0,\n    /**\n     * @generated from protobuf enum value: Zuora = 1;\n     */\n    Zuora = 1,\n    /**\n     * @generated from protobuf enum value: Azure = 2;\n     */\n    Azure = 2\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.DiscountTargetType\n */\nexport enum DiscountTargetType {\n    /**\n     * @generated from protobuf enum value: NoDiscountTarget = 0;\n     */\n    NoDiscountTarget = 0,\n    /**\n     * @generated from protobuf enum value: SkuDiscount = 1;\n     */\n    SkuDiscount = 1,\n    /**\n     * @generated from protobuf enum value: ProductDiscount = 2;\n     */\n    ProductDiscount = 2,\n    /**\n     * @generated from protobuf enum value: RepoDiscount = 3;\n     */\n    RepoDiscount = 3,\n    /**\n     * @generated from protobuf enum value: OrgDiscount = 4;\n     */\n    OrgDiscount = 4,\n    /**\n     * @generated from protobuf enum value: EnterpriseDiscount = 5;\n     */\n    EnterpriseDiscount = 5\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass CreateCustomerRequest$Type extends MessageType<CreateCustomerRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.CreateCustomerRequest\", [\n            { no: 1, name: \"customer\", kind: \"message\", T: () => Customer }\n        ]);\n    }\n    create(value?: PartialMessage<CreateCustomerRequest>): CreateCustomerRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CreateCustomerRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateCustomerRequest): CreateCustomerRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Customer customer */ 1:\n                    message.customer = Customer.internalBinaryRead(reader, reader.uint32(), options, message.customer);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CreateCustomerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Customer customer = 1; */\n        if (message.customer)\n            Customer.internalBinaryWrite(message.customer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CreateCustomerRequest\n */\nexport const CreateCustomerRequest = new CreateCustomerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CreateCustomerResponse$Type extends MessageType<CreateCustomerResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.CreateCustomerResponse\", []);\n    }\n    create(value?: PartialMessage<CreateCustomerResponse>): CreateCustomerResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CreateCustomerResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateCustomerResponse): CreateCustomerResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: CreateCustomerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CreateCustomerResponse\n */\nexport const CreateCustomerResponse = new CreateCustomerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PatchCustomerRequest$Type extends MessageType<PatchCustomerRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.PatchCustomerRequest\", [\n            { no: 1, name: \"customer\", kind: \"message\", T: () => Customer }\n        ]);\n    }\n    create(value?: PartialMessage<PatchCustomerRequest>): PatchCustomerRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<PatchCustomerRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchCustomerRequest): PatchCustomerRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Customer customer */ 1:\n                    message.customer = Customer.internalBinaryRead(reader, reader.uint32(), options, message.customer);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PatchCustomerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Customer customer = 1; */\n        if (message.customer)\n            Customer.internalBinaryWrite(message.customer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.PatchCustomerRequest\n */\nexport const PatchCustomerRequest = new PatchCustomerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PatchCustomerResponse$Type extends MessageType<PatchCustomerResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.PatchCustomerResponse\", []);\n    }\n    create(value?: PartialMessage<PatchCustomerResponse>): PatchCustomerResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<PatchCustomerResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchCustomerResponse): PatchCustomerResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: PatchCustomerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.PatchCustomerResponse\n */\nexport const PatchCustomerResponse = new PatchCustomerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCustomerRequest$Type extends MessageType<GetCustomerRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCustomerRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetCustomerRequest>): GetCustomerRequest {\n        const message = { customerId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCustomerRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCustomerRequest): GetCustomerRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCustomerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCustomerRequest\n */\nexport const GetCustomerRequest = new GetCustomerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCustomerResponse$Type extends MessageType<GetCustomerResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCustomerResponse\", [\n            { no: 1, name: \"customer\", kind: \"message\", T: () => Customer }\n        ]);\n    }\n    create(value?: PartialMessage<GetCustomerResponse>): GetCustomerResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCustomerResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCustomerResponse): GetCustomerResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Customer customer */ 1:\n                    message.customer = Customer.internalBinaryRead(reader, reader.uint32(), options, message.customer);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCustomerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Customer customer = 1; */\n        if (message.customer)\n            Customer.internalBinaryWrite(message.customer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCustomerResponse\n */\nexport const GetCustomerResponse = new GetCustomerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCustomersRequest$Type extends MessageType<GetCustomersRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCustomersRequest\", [\n            { no: 1, name: \"customerIds\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetCustomersRequest>): GetCustomersRequest {\n        const message = { customerIds: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCustomersRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCustomersRequest): GetCustomersRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated string customerIds */ 1:\n                    message.customerIds.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCustomersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated string customerIds = 1; */\n        for (let i = 0; i < message.customerIds.length; i++)\n            writer.tag(1, WireType.LengthDelimited).string(message.customerIds[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCustomersRequest\n */\nexport const GetCustomersRequest = new GetCustomersRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetCustomersResponse$Type extends MessageType<GetCustomersResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetCustomersResponse\", [\n            { no: 1, name: \"customers\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Customer }\n        ]);\n    }\n    create(value?: PartialMessage<GetCustomersResponse>): GetCustomersResponse {\n        const message = { customers: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetCustomersResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCustomersResponse): GetCustomersResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Customer customers */ 1:\n                    message.customers.push(Customer.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetCustomersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Customer customers = 1; */\n        for (let i = 0; i < message.customers.length; i++)\n            Customer.internalBinaryWrite(message.customers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetCustomersResponse\n */\nexport const GetCustomersResponse = new GetCustomersResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertBudgetRequest$Type extends MessageType<UpsertBudgetRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertBudgetRequest\", [\n            { no: 1, name: \"budget\", kind: \"message\", T: () => Budget }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertBudgetRequest>): UpsertBudgetRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertBudgetRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertBudgetRequest): UpsertBudgetRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Budget budget */ 1:\n                    message.budget = Budget.internalBinaryRead(reader, reader.uint32(), options, message.budget);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertBudgetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Budget budget = 1; */\n        if (message.budget)\n            Budget.internalBinaryWrite(message.budget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertBudgetRequest\n */\nexport const UpsertBudgetRequest = new UpsertBudgetRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertBudgetResponse$Type extends MessageType<UpsertBudgetResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertBudgetResponse\", []);\n    }\n    create(value?: PartialMessage<UpsertBudgetResponse>): UpsertBudgetResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertBudgetResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertBudgetResponse): UpsertBudgetResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: UpsertBudgetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertBudgetResponse\n */\nexport const UpsertBudgetResponse = new UpsertBudgetResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DeleteBudgetRequest$Type extends MessageType<DeleteBudgetRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.DeleteBudgetRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<DeleteBudgetRequest>): DeleteBudgetRequest {\n        const message = { customerId: \"\", uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DeleteBudgetRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteBudgetRequest): DeleteBudgetRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string uuid */ 2:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: DeleteBudgetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string uuid = 2; */\n        if (message.uuid !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DeleteBudgetRequest\n */\nexport const DeleteBudgetRequest = new DeleteBudgetRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DeleteBudgetResponse$Type extends MessageType<DeleteBudgetResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.DeleteBudgetResponse\", []);\n    }\n    create(value?: PartialMessage<DeleteBudgetResponse>): DeleteBudgetResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DeleteBudgetResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteBudgetResponse): DeleteBudgetResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: DeleteBudgetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DeleteBudgetResponse\n */\nexport const DeleteBudgetResponse = new DeleteBudgetResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetRequest$Type extends MessageType<GetBudgetRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetRequest\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => BudgetKey }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetRequest>): GetBudgetRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetRequest): GetBudgetRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.BudgetKey key */ 1:\n                    message.key = BudgetKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.BudgetKey key = 1; */\n        if (message.key)\n            BudgetKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetRequest\n */\nexport const GetBudgetRequest = new GetBudgetRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetResponse$Type extends MessageType<GetBudgetResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetResponse\", [\n            { no: 1, name: \"budget\", kind: \"message\", T: () => Budget }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetResponse>): GetBudgetResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetResponse): GetBudgetResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Budget budget */ 1:\n                    message.budget = Budget.internalBinaryRead(reader, reader.uint32(), options, message.budget);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Budget budget = 1; */\n        if (message.budget)\n            Budget.internalBinaryWrite(message.budget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetResponse\n */\nexport const GetBudgetResponse = new GetBudgetResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetByUuidRequest$Type extends MessageType<GetBudgetByUuidRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetByUuidRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetByUuidRequest>): GetBudgetByUuidRequest {\n        const message = { customerId: \"\", uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetByUuidRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetByUuidRequest): GetBudgetByUuidRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string uuid */ 2:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetByUuidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string uuid = 2; */\n        if (message.uuid !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetByUuidRequest\n */\nexport const GetBudgetByUuidRequest = new GetBudgetByUuidRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetByUuidResponse$Type extends MessageType<GetBudgetByUuidResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetByUuidResponse\", [\n            { no: 1, name: \"budget\", kind: \"message\", T: () => Budget }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetByUuidResponse>): GetBudgetByUuidResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetByUuidResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetByUuidResponse): GetBudgetByUuidResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Budget budget */ 1:\n                    message.budget = Budget.internalBinaryRead(reader, reader.uint32(), options, message.budget);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetByUuidResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Budget budget = 1; */\n        if (message.budget)\n            Budget.internalBinaryWrite(message.budget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetByUuidResponse\n */\nexport const GetBudgetByUuidResponse = new GetBudgetByUuidResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllBudgetsRequest$Type extends MessageType<GetAllBudgetsRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllBudgetsRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllBudgetsRequest>): GetAllBudgetsRequest {\n        const message = { customerId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllBudgetsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllBudgetsRequest): GetAllBudgetsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllBudgetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllBudgetsRequest\n */\nexport const GetAllBudgetsRequest = new GetAllBudgetsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllBudgetsResponse$Type extends MessageType<GetAllBudgetsResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllBudgetsResponse\", [\n            { no: 1, name: \"budgets\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => BudgetInfo }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllBudgetsResponse>): GetAllBudgetsResponse {\n        const message = { budgets: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllBudgetsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllBudgetsResponse): GetAllBudgetsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.BudgetInfo budgets */ 1:\n                    message.budgets.push(BudgetInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllBudgetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.BudgetInfo budgets = 1; */\n        for (let i = 0; i < message.budgets.length; i++)\n            BudgetInfo.internalBinaryWrite(message.budgets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllBudgetsResponse\n */\nexport const GetAllBudgetsResponse = new GetAllBudgetsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BudgetInfo$Type extends MessageType<BudgetInfo> {\n    constructor() {\n        super(\"billing_platform.api.v1.BudgetInfo\", [\n            { no: 1, name: \"budget\", kind: \"message\", T: () => Budget },\n            { no: 2, name: \"budgetState\", kind: \"message\", T: () => BudgetState }\n        ]);\n    }\n    create(value?: PartialMessage<BudgetInfo>): BudgetInfo {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BudgetInfo>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BudgetInfo): BudgetInfo {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Budget budget */ 1:\n                    message.budget = Budget.internalBinaryRead(reader, reader.uint32(), options, message.budget);\n                    break;\n                case /* billing_platform.api.v1.BudgetState budgetState */ 2:\n                    message.budgetState = BudgetState.internalBinaryRead(reader, reader.uint32(), options, message.budgetState);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BudgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Budget budget = 1; */\n        if (message.budget)\n            Budget.internalBinaryWrite(message.budget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* billing_platform.api.v1.BudgetState budgetState = 2; */\n        if (message.budgetState)\n            BudgetState.internalBinaryWrite(message.budgetState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BudgetInfo\n */\nexport const BudgetInfo = new BudgetInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetStateRequest$Type extends MessageType<GetBudgetStateRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetStateRequest\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => BudgetKey },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetStateRequest>): GetBudgetStateRequest {\n        const message = { year: \"0\", month: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetStateRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetStateRequest): GetBudgetStateRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.BudgetKey key */ 1:\n                    message.key = BudgetKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.BudgetKey key = 1; */\n        if (message.key)\n            BudgetKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetStateRequest\n */\nexport const GetBudgetStateRequest = new GetBudgetStateRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetBudgetStateResponse$Type extends MessageType<GetBudgetStateResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetBudgetStateResponse\", [\n            { no: 1, name: \"budgetState\", kind: \"message\", T: () => BudgetState }\n        ]);\n    }\n    create(value?: PartialMessage<GetBudgetStateResponse>): GetBudgetStateResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetBudgetStateResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBudgetStateResponse): GetBudgetStateResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.BudgetState budgetState */ 1:\n                    message.budgetState = BudgetState.internalBinaryRead(reader, reader.uint32(), options, message.budgetState);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetBudgetStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.BudgetState budgetState = 1; */\n        if (message.budgetState)\n            BudgetState.internalBinaryWrite(message.budgetState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetBudgetStateResponse\n */\nexport const GetBudgetStateResponse = new GetBudgetStateResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CanProceedWithUsageRequest$Type extends MessageType<CanProceedWithUsageRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.CanProceedWithUsageRequest\", [\n            { no: 1, name: \"usageKey\", kind: \"message\", T: () => UsageKey }\n        ]);\n    }\n    create(value?: PartialMessage<CanProceedWithUsageRequest>): CanProceedWithUsageRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CanProceedWithUsageRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CanProceedWithUsageRequest): CanProceedWithUsageRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.UsageKey usageKey */ 1:\n                    message.usageKey = UsageKey.internalBinaryRead(reader, reader.uint32(), options, message.usageKey);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CanProceedWithUsageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.UsageKey usageKey = 1; */\n        if (message.usageKey)\n            UsageKey.internalBinaryWrite(message.usageKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CanProceedWithUsageRequest\n */\nexport const CanProceedWithUsageRequest = new CanProceedWithUsageRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CanProceedWithUsageResponse$Type extends MessageType<CanProceedWithUsageResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.CanProceedWithUsageResponse\", [\n            { no: 1, name: \"canProceed\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 2, name: \"applicableBudgets\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => CanProceedWithUsageInfo }\n        ]);\n    }\n    create(value?: PartialMessage<CanProceedWithUsageResponse>): CanProceedWithUsageResponse {\n        const message = { canProceed: false, applicableBudgets: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CanProceedWithUsageResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CanProceedWithUsageResponse): CanProceedWithUsageResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool canProceed */ 1:\n                    message.canProceed = reader.bool();\n                    break;\n                case /* repeated billing_platform.api.v1.CanProceedWithUsageInfo applicableBudgets */ 2:\n                    message.applicableBudgets.push(CanProceedWithUsageInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CanProceedWithUsageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool canProceed = 1; */\n        if (message.canProceed !== false)\n            writer.tag(1, WireType.Varint).bool(message.canProceed);\n        /* repeated billing_platform.api.v1.CanProceedWithUsageInfo applicableBudgets = 2; */\n        for (let i = 0; i < message.applicableBudgets.length; i++)\n            CanProceedWithUsageInfo.internalBinaryWrite(message.applicableBudgets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CanProceedWithUsageResponse\n */\nexport const CanProceedWithUsageResponse = new CanProceedWithUsageResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllDiscountsRequest$Type extends MessageType<GetAllDiscountsRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllDiscountsRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllDiscountsRequest>): GetAllDiscountsRequest {\n        const message = { customerId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllDiscountsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllDiscountsRequest): GetAllDiscountsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllDiscountsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllDiscountsRequest\n */\nexport const GetAllDiscountsRequest = new GetAllDiscountsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllDiscountStatesRequest$Type extends MessageType<GetAllDiscountStatesRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllDiscountStatesRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllDiscountStatesRequest>): GetAllDiscountStatesRequest {\n        const message = { customerId: \"\", year: \"0\", month: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllDiscountStatesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllDiscountStatesRequest): GetAllDiscountStatesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllDiscountStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllDiscountStatesRequest\n */\nexport const GetAllDiscountStatesRequest = new GetAllDiscountStatesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllDiscountsResponse$Type extends MessageType<GetAllDiscountsResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllDiscountsResponse\", [\n            { no: 1, name: \"discounts\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Discount }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllDiscountsResponse>): GetAllDiscountsResponse {\n        const message = { discounts: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllDiscountsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllDiscountsResponse): GetAllDiscountsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Discount discounts */ 1:\n                    message.discounts.push(Discount.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllDiscountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Discount discounts = 1; */\n        for (let i = 0; i < message.discounts.length; i++)\n            Discount.internalBinaryWrite(message.discounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllDiscountsResponse\n */\nexport const GetAllDiscountsResponse = new GetAllDiscountsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllDiscountStatesResponse$Type extends MessageType<GetAllDiscountStatesResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllDiscountStatesResponse\", [\n            { no: 1, name: \"discounts\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => DiscountState }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllDiscountStatesResponse>): GetAllDiscountStatesResponse {\n        const message = { discounts: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllDiscountStatesResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllDiscountStatesResponse): GetAllDiscountStatesResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.DiscountState discounts */ 1:\n                    message.discounts.push(DiscountState.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllDiscountStatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.DiscountState discounts = 1; */\n        for (let i = 0; i < message.discounts.length; i++)\n            DiscountState.internalBinaryWrite(message.discounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllDiscountStatesResponse\n */\nexport const GetAllDiscountStatesResponse = new GetAllDiscountStatesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountRequest$Type extends MessageType<GetDiscountRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountRequest\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => DiscountKey }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountRequest>): GetDiscountRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountRequest): GetDiscountRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.DiscountKey key */ 1:\n                    message.key = DiscountKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.DiscountKey key = 1; */\n        if (message.key)\n            DiscountKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountRequest\n */\nexport const GetDiscountRequest = new GetDiscountRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountResponse$Type extends MessageType<GetDiscountResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountResponse\", [\n            { no: 1, name: \"discount\", kind: \"message\", T: () => Discount }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountResponse>): GetDiscountResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountResponse): GetDiscountResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Discount discount */ 1:\n                    message.discount = Discount.internalBinaryRead(reader, reader.uint32(), options, message.discount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Discount discount = 1; */\n        if (message.discount)\n            Discount.internalBinaryWrite(message.discount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountResponse\n */\nexport const GetDiscountResponse = new GetDiscountResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CreateDiscountRequest$Type extends MessageType<CreateDiscountRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.CreateDiscountRequest\", [\n            { no: 1, name: \"discount\", kind: \"message\", T: () => Discount }\n        ]);\n    }\n    create(value?: PartialMessage<CreateDiscountRequest>): CreateDiscountRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CreateDiscountRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDiscountRequest): CreateDiscountRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Discount discount */ 1:\n                    message.discount = Discount.internalBinaryRead(reader, reader.uint32(), options, message.discount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CreateDiscountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Discount discount = 1; */\n        if (message.discount)\n            Discount.internalBinaryWrite(message.discount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CreateDiscountRequest\n */\nexport const CreateDiscountRequest = new CreateDiscountRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CreateDiscountResponse$Type extends MessageType<CreateDiscountResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.CreateDiscountResponse\", [\n            { no: 1, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<CreateDiscountResponse>): CreateDiscountResponse {\n        const message = { uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CreateDiscountResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDiscountResponse): CreateDiscountResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string uuid */ 1:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CreateDiscountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string uuid = 1; */\n        if (message.uuid !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CreateDiscountResponse\n */\nexport const CreateDiscountResponse = new CreateDiscountResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountStateRequest$Type extends MessageType<GetDiscountStateRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountStateRequest\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => DiscountKey },\n            { no: 3, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountStateRequest>): GetDiscountStateRequest {\n        const message = { year: \"0\", month: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountStateRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountStateRequest): GetDiscountStateRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.DiscountKey key */ 1:\n                    message.key = DiscountKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                case /* int64 year */ 3:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 4:\n                    message.month = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.DiscountKey key = 1; */\n        if (message.key)\n            DiscountKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* int64 year = 3; */\n        if (message.year !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.year);\n        /* int64 month = 4; */\n        if (message.month !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.month);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountStateRequest\n */\nexport const GetDiscountStateRequest = new GetDiscountStateRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountStateResponse$Type extends MessageType<GetDiscountStateResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountStateResponse\", [\n            { no: 1, name: \"discountState\", kind: \"message\", T: () => DiscountState }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountStateResponse>): GetDiscountStateResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountStateResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountStateResponse): GetDiscountStateResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.DiscountState discountState */ 1:\n                    message.discountState = DiscountState.internalBinaryRead(reader, reader.uint32(), options, message.discountState);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.DiscountState discountState = 1; */\n        if (message.discountState)\n            DiscountState.internalBinaryWrite(message.discountState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountStateResponse\n */\nexport const GetDiscountStateResponse = new GetDiscountStateResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Customer$Type extends MessageType<Customer> {\n    constructor() {\n        super(\"billing_platform.api.v1.Customer\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"CostCenterUUID\", kind: \"scalar\", jsonName: \"CostCenterUUID\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"IsCostCenterProxy\", kind: \"scalar\", jsonName: \"IsCostCenterProxy\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 4, name: \"billingTarget\", kind: \"enum\", T: () => [\"billing_platform.api.v1.BillingTarget\", BillingTarget] },\n            { no: 5, name: \"azureAccountId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 6, name: \"zuoraAccountId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 7, name: \"enterpriseCustomerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 8, name: \"enableUsageEmission\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 9, name: \"zuoraAccountNumber\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 10, name: \"discountPlanName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 11, name: \"billForPublicRepoUsage\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 12, name: \"effectiveAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 13, name: \"enabledProducts\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 14, name: \"hasPaymentMethod\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Customer>): Customer {\n        const message = { customerId: \"\", costCenterUUID: \"\", isCostCenterProxy: false, billingTarget: 0, azureAccountId: \"\", zuoraAccountId: \"\", enterpriseCustomerId: \"\", enableUsageEmission: false, zuoraAccountNumber: \"\", discountPlanName: \"\", billForPublicRepoUsage: false, effectiveAt: \"0\", enabledProducts: [], hasPaymentMethod: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Customer>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Customer): Customer {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string CostCenterUUID = 2 [json_name = \"CostCenterUUID\"];*/ 2:\n                    message.costCenterUUID = reader.string();\n                    break;\n                case /* bool IsCostCenterProxy = 3 [json_name = \"IsCostCenterProxy\"];*/ 3:\n                    message.isCostCenterProxy = reader.bool();\n                    break;\n                case /* billing_platform.api.v1.BillingTarget billingTarget */ 4:\n                    message.billingTarget = reader.int32();\n                    break;\n                case /* string azureAccountId */ 5:\n                    message.azureAccountId = reader.string();\n                    break;\n                case /* string zuoraAccountId */ 6:\n                    message.zuoraAccountId = reader.string();\n                    break;\n                case /* string enterpriseCustomerId */ 7:\n                    message.enterpriseCustomerId = reader.string();\n                    break;\n                case /* bool enableUsageEmission */ 8:\n                    message.enableUsageEmission = reader.bool();\n                    break;\n                case /* string zuoraAccountNumber */ 9:\n                    message.zuoraAccountNumber = reader.string();\n                    break;\n                case /* string discountPlanName */ 10:\n                    message.discountPlanName = reader.string();\n                    break;\n                case /* bool billForPublicRepoUsage */ 11:\n                    message.billForPublicRepoUsage = reader.bool();\n                    break;\n                case /* int64 effectiveAt */ 12:\n                    message.effectiveAt = reader.int64().toString();\n                    break;\n                case /* repeated string enabledProducts */ 13:\n                    message.enabledProducts.push(reader.string());\n                    break;\n                case /* bool hasPaymentMethod */ 14:\n                    message.hasPaymentMethod = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Customer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string CostCenterUUID = 2 [json_name = \"CostCenterUUID\"]; */\n        if (message.costCenterUUID !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.costCenterUUID);\n        /* bool IsCostCenterProxy = 3 [json_name = \"IsCostCenterProxy\"]; */\n        if (message.isCostCenterProxy !== false)\n            writer.tag(3, WireType.Varint).bool(message.isCostCenterProxy);\n        /* billing_platform.api.v1.BillingTarget billingTarget = 4; */\n        if (message.billingTarget !== 0)\n            writer.tag(4, WireType.Varint).int32(message.billingTarget);\n        /* string azureAccountId = 5; */\n        if (message.azureAccountId !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.azureAccountId);\n        /* string zuoraAccountId = 6; */\n        if (message.zuoraAccountId !== \"\")\n            writer.tag(6, WireType.LengthDelimited).string(message.zuoraAccountId);\n        /* string enterpriseCustomerId = 7; */\n        if (message.enterpriseCustomerId !== \"\")\n            writer.tag(7, WireType.LengthDelimited).string(message.enterpriseCustomerId);\n        /* bool enableUsageEmission = 8; */\n        if (message.enableUsageEmission !== false)\n            writer.tag(8, WireType.Varint).bool(message.enableUsageEmission);\n        /* string zuoraAccountNumber = 9; */\n        if (message.zuoraAccountNumber !== \"\")\n            writer.tag(9, WireType.LengthDelimited).string(message.zuoraAccountNumber);\n        /* string discountPlanName = 10; */\n        if (message.discountPlanName !== \"\")\n            writer.tag(10, WireType.LengthDelimited).string(message.discountPlanName);\n        /* bool billForPublicRepoUsage = 11; */\n        if (message.billForPublicRepoUsage !== false)\n            writer.tag(11, WireType.Varint).bool(message.billForPublicRepoUsage);\n        /* int64 effectiveAt = 12; */\n        if (message.effectiveAt !== \"0\")\n            writer.tag(12, WireType.Varint).int64(message.effectiveAt);\n        /* repeated string enabledProducts = 13; */\n        for (let i = 0; i < message.enabledProducts.length; i++)\n            writer.tag(13, WireType.LengthDelimited).string(message.enabledProducts[i]);\n        /* bool hasPaymentMethod = 14; */\n        if (message.hasPaymentMethod !== false)\n            writer.tag(14, WireType.Varint).bool(message.hasPaymentMethod);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Customer\n */\nexport const Customer = new Customer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Budget$Type extends MessageType<Budget> {\n    constructor() {\n        super(\"billing_platform.api.v1.Budget\", [\n            { no: 1, name: \"key\", kind: \"message\", T: () => BudgetKey },\n            { no: 2, name: \"targetAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 3, name: \"budgetLimitType\", kind: \"enum\", T: () => [\"billing_platform.api.v1.BudgetLimitType\", BudgetLimitType] },\n            { no: 4, name: \"budgetAlerting\", kind: \"message\", T: () => BudgetAlerting },\n            { no: 5, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Budget>): Budget {\n        const message = { targetAmount: 0, budgetLimitType: 0, uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Budget>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Budget): Budget {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.BudgetKey key */ 1:\n                    message.key = BudgetKey.internalBinaryRead(reader, reader.uint32(), options, message.key);\n                    break;\n                case /* double targetAmount */ 2:\n                    message.targetAmount = reader.double();\n                    break;\n                case /* billing_platform.api.v1.BudgetLimitType budgetLimitType */ 3:\n                    message.budgetLimitType = reader.int32();\n                    break;\n                case /* billing_platform.api.v1.BudgetAlerting budgetAlerting */ 4:\n                    message.budgetAlerting = BudgetAlerting.internalBinaryRead(reader, reader.uint32(), options, message.budgetAlerting);\n                    break;\n                case /* string uuid */ 5:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Budget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.BudgetKey key = 1; */\n        if (message.key)\n            BudgetKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* double targetAmount = 2; */\n        if (message.targetAmount !== 0)\n            writer.tag(2, WireType.Bit64).double(message.targetAmount);\n        /* billing_platform.api.v1.BudgetLimitType budgetLimitType = 3; */\n        if (message.budgetLimitType !== 0)\n            writer.tag(3, WireType.Varint).int32(message.budgetLimitType);\n        /* billing_platform.api.v1.BudgetAlerting budgetAlerting = 4; */\n        if (message.budgetAlerting)\n            BudgetAlerting.internalBinaryWrite(message.budgetAlerting, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        /* string uuid = 5; */\n        if (message.uuid !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Budget\n */\nexport const Budget = new Budget$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BudgetKey$Type extends MessageType<BudgetKey> {\n    constructor() {\n        super(\"billing_platform.api.v1.BudgetKey\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"targetType\", kind: \"enum\", T: () => [\"billing_platform.base.ResourceType\", ResourceType] },\n            { no: 3, name: \"targetId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"pricingTargetType\", kind: \"enum\", T: () => [\"billing_platform.api.v1.PricingTargetType\", PricingTargetType] },\n            { no: 5, name: \"pricingTargetId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<BudgetKey>): BudgetKey {\n        const message = { customerId: \"\", targetType: 0, targetId: \"\", pricingTargetType: 0, pricingTargetId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BudgetKey>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BudgetKey): BudgetKey {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* billing_platform.base.ResourceType targetType */ 2:\n                    message.targetType = reader.int32();\n                    break;\n                case /* string targetId */ 3:\n                    message.targetId = reader.string();\n                    break;\n                case /* billing_platform.api.v1.PricingTargetType pricingTargetType */ 4:\n                    message.pricingTargetType = reader.int32();\n                    break;\n                case /* string pricingTargetId */ 5:\n                    message.pricingTargetId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BudgetKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* billing_platform.base.ResourceType targetType = 2; */\n        if (message.targetType !== 0)\n            writer.tag(2, WireType.Varint).int32(message.targetType);\n        /* string targetId = 3; */\n        if (message.targetId !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.targetId);\n        /* billing_platform.api.v1.PricingTargetType pricingTargetType = 4; */\n        if (message.pricingTargetType !== 0)\n            writer.tag(4, WireType.Varint).int32(message.pricingTargetType);\n        /* string pricingTargetId = 5; */\n        if (message.pricingTargetId !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.pricingTargetId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BudgetKey\n */\nexport const BudgetKey = new BudgetKey$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BudgetState$Type extends MessageType<BudgetState> {\n    constructor() {\n        super(\"billing_platform.api.v1.BudgetState\", [\n            { no: 1, name: \"isFullyFunded\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 2, name: \"currentAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 3, name: \"targetAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"thresholdMet\", kind: \"message\", T: () => BudgetThreshold }\n        ]);\n    }\n    create(value?: PartialMessage<BudgetState>): BudgetState {\n        const message = { isFullyFunded: false, currentAmount: 0, targetAmount: 0, quantity: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BudgetState>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BudgetState): BudgetState {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool isFullyFunded */ 1:\n                    message.isFullyFunded = reader.bool();\n                    break;\n                case /* double currentAmount */ 2:\n                    message.currentAmount = reader.double();\n                    break;\n                case /* double targetAmount */ 3:\n                    message.targetAmount = reader.double();\n                    break;\n                case /* double quantity */ 4:\n                    message.quantity = reader.double();\n                    break;\n                case /* billing_platform.api.v1.BudgetThreshold thresholdMet */ 5:\n                    message.thresholdMet = BudgetThreshold.internalBinaryRead(reader, reader.uint32(), options, message.thresholdMet);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BudgetState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool isFullyFunded = 1; */\n        if (message.isFullyFunded !== false)\n            writer.tag(1, WireType.Varint).bool(message.isFullyFunded);\n        /* double currentAmount = 2; */\n        if (message.currentAmount !== 0)\n            writer.tag(2, WireType.Bit64).double(message.currentAmount);\n        /* double targetAmount = 3; */\n        if (message.targetAmount !== 0)\n            writer.tag(3, WireType.Bit64).double(message.targetAmount);\n        /* double quantity = 4; */\n        if (message.quantity !== 0)\n            writer.tag(4, WireType.Bit64).double(message.quantity);\n        /* billing_platform.api.v1.BudgetThreshold thresholdMet = 5; */\n        if (message.thresholdMet)\n            BudgetThreshold.internalBinaryWrite(message.thresholdMet, writer.tag(5, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BudgetState\n */\nexport const BudgetState = new BudgetState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BudgetAlerting$Type extends MessageType<BudgetAlerting> {\n    constructor() {\n        super(\"billing_platform.api.v1.BudgetAlerting\", [\n            { no: 1, name: \"willAlert\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 2, name: \"recipientUserIds\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<BudgetAlerting>): BudgetAlerting {\n        const message = { willAlert: false, recipientUserIds: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BudgetAlerting>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BudgetAlerting): BudgetAlerting {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool willAlert */ 1:\n                    message.willAlert = reader.bool();\n                    break;\n                case /* repeated string recipientUserIds */ 2:\n                    message.recipientUserIds.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BudgetAlerting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool willAlert = 1; */\n        if (message.willAlert !== false)\n            writer.tag(1, WireType.Varint).bool(message.willAlert);\n        /* repeated string recipientUserIds = 2; */\n        for (let i = 0; i < message.recipientUserIds.length; i++)\n            writer.tag(2, WireType.LengthDelimited).string(message.recipientUserIds[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BudgetAlerting\n */\nexport const BudgetAlerting = new BudgetAlerting$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BudgetThreshold$Type extends MessageType<BudgetThreshold> {\n    constructor() {\n        super(\"billing_platform.api.v1.BudgetThreshold\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"minimumUsagePercentage\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 3, name: \"alertable\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<BudgetThreshold>): BudgetThreshold {\n        const message = { name: \"\", minimumUsagePercentage: 0, alertable: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BudgetThreshold>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BudgetThreshold): BudgetThreshold {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* double minimumUsagePercentage */ 2:\n                    message.minimumUsagePercentage = reader.double();\n                    break;\n                case /* bool alertable */ 3:\n                    message.alertable = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BudgetThreshold, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        /* double minimumUsagePercentage = 2; */\n        if (message.minimumUsagePercentage !== 0)\n            writer.tag(2, WireType.Bit64).double(message.minimumUsagePercentage);\n        /* bool alertable = 3; */\n        if (message.alertable !== false)\n            writer.tag(3, WireType.Varint).bool(message.alertable);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BudgetThreshold\n */\nexport const BudgetThreshold = new BudgetThreshold$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CanProceedWithUsageInfo$Type extends MessageType<CanProceedWithUsageInfo> {\n    constructor() {\n        super(\"billing_platform.api.v1.CanProceedWithUsageInfo\", [\n            { no: 1, name: \"budgetKey\", kind: \"message\", T: () => BudgetKey },\n            { no: 2, name: \"budgetState\", kind: \"message\", T: () => BudgetState },\n            { no: 3, name: \"budgetLimitType\", kind: \"enum\", T: () => [\"billing_platform.api.v1.BudgetLimitType\", BudgetLimitType] }\n        ]);\n    }\n    create(value?: PartialMessage<CanProceedWithUsageInfo>): CanProceedWithUsageInfo {\n        const message = { budgetLimitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<CanProceedWithUsageInfo>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CanProceedWithUsageInfo): CanProceedWithUsageInfo {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.BudgetKey budgetKey */ 1:\n                    message.budgetKey = BudgetKey.internalBinaryRead(reader, reader.uint32(), options, message.budgetKey);\n                    break;\n                case /* billing_platform.api.v1.BudgetState budgetState */ 2:\n                    message.budgetState = BudgetState.internalBinaryRead(reader, reader.uint32(), options, message.budgetState);\n                    break;\n                case /* billing_platform.api.v1.BudgetLimitType budgetLimitType */ 3:\n                    message.budgetLimitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CanProceedWithUsageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.BudgetKey budgetKey = 1; */\n        if (message.budgetKey)\n            BudgetKey.internalBinaryWrite(message.budgetKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* billing_platform.api.v1.BudgetState budgetState = 2; */\n        if (message.budgetState)\n            BudgetState.internalBinaryWrite(message.budgetState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* billing_platform.api.v1.BudgetLimitType budgetLimitType = 3; */\n        if (message.budgetLimitType !== 0)\n            writer.tag(3, WireType.Varint).int32(message.budgetLimitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.CanProceedWithUsageInfo\n */\nexport const CanProceedWithUsageInfo = new CanProceedWithUsageInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UsageKey$Type extends MessageType<UsageKey> {\n    constructor() {\n        super(\"billing_platform.api.v1.UsageKey\", [\n            { no: 1, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"usageAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"entityDetail\", kind: \"message\", T: () => EntityDetail }\n        ]);\n    }\n    create(value?: PartialMessage<UsageKey>): UsageKey {\n        const message = { sku: \"\", product: \"\", quantity: 0, usageAt: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UsageKey>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageKey): UsageKey {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 1:\n                    message.sku = reader.string();\n                    break;\n                case /* string product */ 2:\n                    message.product = reader.string();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                case /* int64 usageAt */ 4:\n                    message.usageAt = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.EntityDetail entityDetail */ 5:\n                    message.entityDetail = EntityDetail.internalBinaryRead(reader, reader.uint32(), options, message.entityDetail);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UsageKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 1; */\n        if (message.sku !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.sku);\n        /* string product = 2; */\n        if (message.product !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.product);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        /* int64 usageAt = 4; */\n        if (message.usageAt !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.usageAt);\n        /* billing_platform.base.EntityDetail entityDetail = 5; */\n        if (message.entityDetail)\n            EntityDetail.internalBinaryWrite(message.entityDetail, writer.tag(5, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UsageKey\n */\nexport const UsageKey = new UsageKey$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Discount$Type extends MessageType<Discount> {\n    constructor() {\n        super(\"billing_platform.api.v1.Discount\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"targets\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => DiscountTarget },\n            { no: 3, name: \"percentage\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"targetAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 6, name: \"startDate\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 7, name: \"endDate\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Discount>): Discount {\n        const message = { customerId: \"\", targets: [], percentage: 0, targetAmount: 0, uuid: \"\", startDate: \"0\", endDate: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Discount>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Discount): Discount {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* repeated billing_platform.api.v1.DiscountTarget targets */ 2:\n                    message.targets.push(DiscountTarget.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* double percentage */ 3:\n                    message.percentage = reader.double();\n                    break;\n                case /* double targetAmount */ 4:\n                    message.targetAmount = reader.double();\n                    break;\n                case /* string uuid */ 5:\n                    message.uuid = reader.string();\n                    break;\n                case /* int64 startDate */ 6:\n                    message.startDate = reader.int64().toString();\n                    break;\n                case /* int64 endDate */ 7:\n                    message.endDate = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Discount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* repeated billing_platform.api.v1.DiscountTarget targets = 2; */\n        for (let i = 0; i < message.targets.length; i++)\n            DiscountTarget.internalBinaryWrite(message.targets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* double percentage = 3; */\n        if (message.percentage !== 0)\n            writer.tag(3, WireType.Bit64).double(message.percentage);\n        /* double targetAmount = 4; */\n        if (message.targetAmount !== 0)\n            writer.tag(4, WireType.Bit64).double(message.targetAmount);\n        /* string uuid = 5; */\n        if (message.uuid !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.uuid);\n        /* int64 startDate = 6; */\n        if (message.startDate !== \"0\")\n            writer.tag(6, WireType.Varint).int64(message.startDate);\n        /* int64 endDate = 7; */\n        if (message.endDate !== \"0\")\n            writer.tag(7, WireType.Varint).int64(message.endDate);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Discount\n */\nexport const Discount = new Discount$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DiscountKey$Type extends MessageType<DiscountKey> {\n    constructor() {\n        super(\"billing_platform.api.v1.DiscountKey\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<DiscountKey>): DiscountKey {\n        const message = { customerId: \"\", uuid: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DiscountKey>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscountKey): DiscountKey {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* string uuid */ 2:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: DiscountKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* string uuid = 2; */\n        if (message.uuid !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.uuid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DiscountKey\n */\nexport const DiscountKey = new DiscountKey$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DiscountTarget$Type extends MessageType<DiscountTarget> {\n    constructor() {\n        super(\"billing_platform.api.v1.DiscountTarget\", [\n            { no: 1, name: \"id\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"type\", kind: \"enum\", T: () => [\"billing_platform.api.v1.DiscountTargetType\", DiscountTargetType] }\n        ]);\n    }\n    create(value?: PartialMessage<DiscountTarget>): DiscountTarget {\n        const message = { id: \"\", type: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DiscountTarget>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscountTarget): DiscountTarget {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string id */ 1:\n                    message.id = reader.string();\n                    break;\n                case /* billing_platform.api.v1.DiscountTargetType type */ 2:\n                    message.type = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: DiscountTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string id = 1; */\n        if (message.id !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.id);\n        /* billing_platform.api.v1.DiscountTargetType type = 2; */\n        if (message.type !== 0)\n            writer.tag(2, WireType.Varint).int32(message.type);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DiscountTarget\n */\nexport const DiscountTarget = new DiscountTarget$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DiscountState$Type extends MessageType<DiscountState> {\n    constructor() {\n        super(\"billing_platform.api.v1.DiscountState\", [\n            { no: 1, name: \"isFullyApplied\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 2, name: \"currentAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 3, name: \"targetAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"percentage\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"uuid\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 6, name: \"targets\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => DiscountTarget }\n        ]);\n    }\n    create(value?: PartialMessage<DiscountState>): DiscountState {\n        const message = { isFullyApplied: false, currentAmount: 0, targetAmount: 0, percentage: 0, uuid: \"\", targets: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DiscountState>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscountState): DiscountState {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bool isFullyApplied */ 1:\n                    message.isFullyApplied = reader.bool();\n                    break;\n                case /* double currentAmount */ 2:\n                    message.currentAmount = reader.double();\n                    break;\n                case /* double targetAmount */ 3:\n                    message.targetAmount = reader.double();\n                    break;\n                case /* double percentage */ 4:\n                    message.percentage = reader.double();\n                    break;\n                case /* string uuid */ 5:\n                    message.uuid = reader.string();\n                    break;\n                case /* repeated billing_platform.api.v1.DiscountTarget targets */ 6:\n                    message.targets.push(DiscountTarget.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: DiscountState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bool isFullyApplied = 1; */\n        if (message.isFullyApplied !== false)\n            writer.tag(1, WireType.Varint).bool(message.isFullyApplied);\n        /* double currentAmount = 2; */\n        if (message.currentAmount !== 0)\n            writer.tag(2, WireType.Bit64).double(message.currentAmount);\n        /* double targetAmount = 3; */\n        if (message.targetAmount !== 0)\n            writer.tag(3, WireType.Bit64).double(message.targetAmount);\n        /* double percentage = 4; */\n        if (message.percentage !== 0)\n            writer.tag(4, WireType.Bit64).double(message.percentage);\n        /* string uuid = 5; */\n        if (message.uuid !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.uuid);\n        /* repeated billing_platform.api.v1.DiscountTarget targets = 6; */\n        for (let i = 0; i < message.targets.length; i++)\n            DiscountTarget.internalBinaryWrite(message.targets[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DiscountState\n */\nexport const DiscountState = new DiscountState$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.CustomerApi\n */\nexport const CustomerApi = new ServiceType(\"billing_platform.api.v1.CustomerApi\", [\n    { name: \"UpsertCustomer\", options: {}, I: CreateCustomerRequest, O: CreateCustomerResponse },\n    { name: \"PatchCustomer\", options: {}, I: PatchCustomerRequest, O: PatchCustomerResponse },\n    { name: \"GetCustomer\", options: {}, I: GetCustomerRequest, O: GetCustomerResponse },\n    { name: \"GetCustomers\", options: {}, I: GetCustomersRequest, O: GetCustomersResponse },\n    { name: \"UpsertBudget\", options: {}, I: UpsertBudgetRequest, O: UpsertBudgetResponse },\n    { name: \"GetBudget\", options: {}, I: GetBudgetRequest, O: GetBudgetResponse },\n    { name: \"GetBudgetByUuid\", options: {}, I: GetBudgetByUuidRequest, O: GetBudgetByUuidResponse },\n    { name: \"DeleteBudget\", options: {}, I: DeleteBudgetRequest, O: DeleteBudgetResponse },\n    { name: \"GetAllBudgets\", options: {}, I: GetAllBudgetsRequest, O: GetAllBudgetsResponse },\n    { name: \"GetBudgetState\", options: {}, I: GetBudgetStateRequest, O: GetBudgetStateResponse },\n    { name: \"CanProceedWithUsage\", options: {}, I: CanProceedWithUsageRequest, O: CanProceedWithUsageResponse },\n    { name: \"GetDiscount\", options: {}, I: GetDiscountRequest, O: GetDiscountResponse },\n    { name: \"GetAllDiscounts\", options: {}, I: GetAllDiscountsRequest, O: GetAllDiscountsResponse },\n    { name: \"CreateDiscount\", options: {}, I: CreateDiscountRequest, O: CreateDiscountResponse },\n    { name: \"GetDiscountState\", options: {}, I: GetDiscountStateRequest, O: GetDiscountStateResponse },\n    { name: \"GetAllDiscountStates\", options: {}, I: GetAllDiscountStatesRequest, O: GetAllDiscountStatesResponse }\n]);\n" }, { path: "../ui/src/gen/proto/invoice-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/invoice-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { InvoiceAPI } from \"./invoice-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { GetInvoicesResponse } from \"./invoice-api\";\nimport type { GetInvoicesRequest } from \"./invoice-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.InvoiceAPI\n */\nexport interface IInvoiceAPIClient {\n    /**\n     * @generated from protobuf rpc: GetInvoices(billing_platform.api.v1.GetInvoicesRequest) returns (billing_platform.api.v1.GetInvoicesResponse);\n     */\n    getInvoices(input: GetInvoicesRequest, options?: RpcOptions): UnaryCall<GetInvoicesRequest, GetInvoicesResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.InvoiceAPI\n */\nexport class InvoiceAPIClient implements IInvoiceAPIClient, ServiceInfo {\n    typeName = InvoiceAPI.typeName;\n    methods = InvoiceAPI.methods;\n    options = InvoiceAPI.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetInvoices(billing_platform.api.v1.GetInvoicesRequest) returns (billing_platform.api.v1.GetInvoicesResponse);\n     */\n    getInvoices(input: GetInvoicesRequest, options?: RpcOptions): UnaryCall<GetInvoicesRequest, GetInvoicesResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetInvoicesRequest, GetInvoicesResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/invoice-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/invoice-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Invoice } from \"./usage-api\";\n/**\n * @generated from protobuf message billing_platform.api.v1.GetInvoicesRequest\n */\nexport interface GetInvoicesRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetInvoicesResponse\n */\nexport interface GetInvoicesResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Invoice invoices = 1;\n     */\n    invoices: Invoice[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetInvoicesRequest$Type extends MessageType<GetInvoicesRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetInvoicesRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetInvoicesRequest>): GetInvoicesRequest {\n        const message = { customerId: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetInvoicesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoicesRequest): GetInvoicesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetInvoicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetInvoicesRequest\n */\nexport const GetInvoicesRequest = new GetInvoicesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetInvoicesResponse$Type extends MessageType<GetInvoicesResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetInvoicesResponse\", [\n            { no: 1, name: \"invoices\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Invoice }\n        ]);\n    }\n    create(value?: PartialMessage<GetInvoicesResponse>): GetInvoicesResponse {\n        const message = { invoices: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetInvoicesResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoicesResponse): GetInvoicesResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Invoice invoices */ 1:\n                    message.invoices.push(Invoice.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetInvoicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Invoice invoices = 1; */\n        for (let i = 0; i < message.invoices.length; i++)\n            Invoice.internalBinaryWrite(message.invoices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetInvoicesResponse\n */\nexport const GetInvoicesResponse = new GetInvoicesResponse$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.InvoiceAPI\n */\nexport const InvoiceAPI = new ServiceType(\"billing_platform.api.v1.InvoiceAPI\", [\n    { name: \"GetInvoices\", options: {}, I: GetInvoicesRequest, O: GetInvoicesResponse }\n]);\n" }, { path: "../ui/src/gen/proto/pricing-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/pricing-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { PricingApi } from \"./pricing-api\";\nimport type { UpsertPricingResponse } from \"./pricing-api\";\nimport type { UpsertPricingRequest } from \"./pricing-api\";\nimport type { GetPricingsByProductResponse } from \"./pricing-api\";\nimport type { GetPricingsByProductRequest } from \"./pricing-api\";\nimport type { GetAllPricingResponse } from \"./pricing-api\";\nimport type { GetAllPricingRequest } from \"./pricing-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { GetPricingResponse } from \"./pricing-api\";\nimport type { GetPricingRequest } from \"./pricing-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.PricingApi\n */\nexport interface IPricingApiClient {\n    /**\n     * @generated from protobuf rpc: GetPricing(billing_platform.api.v1.GetPricingRequest) returns (billing_platform.api.v1.GetPricingResponse);\n     */\n    getPricing(input: GetPricingRequest, options?: RpcOptions): UnaryCall<GetPricingRequest, GetPricingResponse>;\n    /**\n     * @generated from protobuf rpc: GetAllPricing(billing_platform.api.v1.GetAllPricingRequest) returns (billing_platform.api.v1.GetAllPricingResponse);\n     */\n    getAllPricing(input: GetAllPricingRequest, options?: RpcOptions): UnaryCall<GetAllPricingRequest, GetAllPricingResponse>;\n    /**\n     * @generated from protobuf rpc: GetPricingsByProduct(billing_platform.api.v1.GetPricingsByProductRequest) returns (billing_platform.api.v1.GetPricingsByProductResponse);\n     */\n    getPricingsByProduct(input: GetPricingsByProductRequest, options?: RpcOptions): UnaryCall<GetPricingsByProductRequest, GetPricingsByProductResponse>;\n    /**\n     * @generated from protobuf rpc: UpsertPricing(billing_platform.api.v1.UpsertPricingRequest) returns (billing_platform.api.v1.UpsertPricingResponse);\n     */\n    upsertPricing(input: UpsertPricingRequest, options?: RpcOptions): UnaryCall<UpsertPricingRequest, UpsertPricingResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.PricingApi\n */\nexport class PricingApiClient implements IPricingApiClient, ServiceInfo {\n    typeName = PricingApi.typeName;\n    methods = PricingApi.methods;\n    options = PricingApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetPricing(billing_platform.api.v1.GetPricingRequest) returns (billing_platform.api.v1.GetPricingResponse);\n     */\n    getPricing(input: GetPricingRequest, options?: RpcOptions): UnaryCall<GetPricingRequest, GetPricingResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetPricingRequest, GetPricingResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetAllPricing(billing_platform.api.v1.GetAllPricingRequest) returns (billing_platform.api.v1.GetAllPricingResponse);\n     */\n    getAllPricing(input: GetAllPricingRequest, options?: RpcOptions): UnaryCall<GetAllPricingRequest, GetAllPricingResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllPricingRequest, GetAllPricingResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetPricingsByProduct(billing_platform.api.v1.GetPricingsByProductRequest) returns (billing_platform.api.v1.GetPricingsByProductResponse);\n     */\n    getPricingsByProduct(input: GetPricingsByProductRequest, options?: RpcOptions): UnaryCall<GetPricingsByProductRequest, GetPricingsByProductResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetPricingsByProductRequest, GetPricingsByProductResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpsertPricing(billing_platform.api.v1.UpsertPricingRequest) returns (billing_platform.api.v1.UpsertPricingResponse);\n     */\n    upsertPricing(input: UpsertPricingRequest, options?: RpcOptions): UnaryCall<UpsertPricingRequest, UpsertPricingResponse> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpsertPricingRequest, UpsertPricingResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/pricing-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/pricing-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { UnitType } from \"./base\";\n/**\n * @generated from protobuf message billing_platform.api.v1.GetPricingRequest\n */\nexport interface GetPricingRequest {\n    /**\n     * @generated from protobuf field: string sku = 1;\n     */\n    sku: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetPricingResponse\n */\nexport interface GetPricingResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Pricing pricing = 1;\n     */\n    pricing?: Pricing;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllPricingRequest\n */\nexport interface GetAllPricingRequest {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllPricingResponse\n */\nexport interface GetAllPricingResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Pricing pricings = 1;\n     */\n    pricings: Pricing[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetPricingsByProductRequest\n */\nexport interface GetPricingsByProductRequest {\n    /**\n     * @generated from protobuf field: string productName = 1;\n     */\n    productName: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetPricingsByProductResponse\n */\nexport interface GetPricingsByProductResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Pricing pricings = 1;\n     */\n    pricings: Pricing[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertPricingRequest\n */\nexport interface UpsertPricingRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Pricing pricing = 1;\n     */\n    pricing?: Pricing;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertPricingResponse\n */\nexport interface UpsertPricingResponse {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Pricing\n */\nexport interface Pricing {\n    /**\n     * @generated from protobuf field: string sku = 1;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: string product = 2;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: double price = 3;\n     */\n    price: number;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.PricingMeterType meterType = 4;\n     */\n    meterType: PricingMeterType;\n    /**\n     * @generated from protobuf field: string friendlyName = 5;\n     */\n    friendlyName: string;\n    /**\n     * @generated from protobuf field: string azureMeterId = 6;\n     */\n    azureMeterId: string;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.HistoricalPrice effectiveDatePrices = 7;\n     */\n    effectiveDatePrices: HistoricalPrice[];\n    /**\n     * @generated from protobuf field: bool freeForPublicRepos = 8;\n     */\n    freeForPublicRepos: boolean;\n    /**\n     * @generated from protobuf field: int64 effectiveAt = 9;\n     */\n    effectiveAt: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.UnitType unitType = 10;\n     */\n    unitType: UnitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.HistoricalPrice\n */\nexport interface HistoricalPrice {\n    /**\n     * @generated from protobuf field: int64 startDate = 1;\n     */\n    startDate: string;\n    /**\n     * @generated from protobuf field: int64 endDate = 2;\n     */\n    endDate: string;\n    /**\n     * @generated from protobuf field: double price = 3;\n     */\n    price: number;\n}\n/**\n * @generated from protobuf enum billing_platform.api.v1.PricingMeterType\n */\nexport enum PricingMeterType {\n    /**\n     * aks DirectSummation, aka actions minutes. defaulting ot zero instead of unknown so that will back fill any existing data by default\n     *\n     * @generated from protobuf enum value: Default = 0;\n     */\n    Default = 0,\n    /**\n     * watermark\n     *\n     * @generated from protobuf enum value: PerHourUnitCharge = 1;\n     */\n    PerHourUnitCharge = 1,\n    /**\n     * high watermark\n     *\n     * @generated from protobuf enum value: DailyUnitCharge = 2;\n     */\n    DailyUnitCharge = 2\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPricingRequest$Type extends MessageType<GetPricingRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetPricingRequest\", [\n            { no: 1, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetPricingRequest>): GetPricingRequest {\n        const message = { sku: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetPricingRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPricingRequest): GetPricingRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 1:\n                    message.sku = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetPricingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 1; */\n        if (message.sku !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.sku);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetPricingRequest\n */\nexport const GetPricingRequest = new GetPricingRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPricingResponse$Type extends MessageType<GetPricingResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetPricingResponse\", [\n            { no: 1, name: \"pricing\", kind: \"message\", T: () => Pricing }\n        ]);\n    }\n    create(value?: PartialMessage<GetPricingResponse>): GetPricingResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetPricingResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPricingResponse): GetPricingResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Pricing pricing */ 1:\n                    message.pricing = Pricing.internalBinaryRead(reader, reader.uint32(), options, message.pricing);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetPricingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Pricing pricing = 1; */\n        if (message.pricing)\n            Pricing.internalBinaryWrite(message.pricing, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetPricingResponse\n */\nexport const GetPricingResponse = new GetPricingResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllPricingRequest$Type extends MessageType<GetAllPricingRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllPricingRequest\", []);\n    }\n    create(value?: PartialMessage<GetAllPricingRequest>): GetAllPricingRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllPricingRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPricingRequest): GetAllPricingRequest {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: GetAllPricingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllPricingRequest\n */\nexport const GetAllPricingRequest = new GetAllPricingRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllPricingResponse$Type extends MessageType<GetAllPricingResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllPricingResponse\", [\n            { no: 1, name: \"pricings\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Pricing }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllPricingResponse>): GetAllPricingResponse {\n        const message = { pricings: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllPricingResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPricingResponse): GetAllPricingResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Pricing pricings */ 1:\n                    message.pricings.push(Pricing.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllPricingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Pricing pricings = 1; */\n        for (let i = 0; i < message.pricings.length; i++)\n            Pricing.internalBinaryWrite(message.pricings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllPricingResponse\n */\nexport const GetAllPricingResponse = new GetAllPricingResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPricingsByProductRequest$Type extends MessageType<GetPricingsByProductRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetPricingsByProductRequest\", [\n            { no: 1, name: \"productName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetPricingsByProductRequest>): GetPricingsByProductRequest {\n        const message = { productName: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetPricingsByProductRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPricingsByProductRequest): GetPricingsByProductRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string productName */ 1:\n                    message.productName = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetPricingsByProductRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string productName = 1; */\n        if (message.productName !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.productName);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetPricingsByProductRequest\n */\nexport const GetPricingsByProductRequest = new GetPricingsByProductRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPricingsByProductResponse$Type extends MessageType<GetPricingsByProductResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetPricingsByProductResponse\", [\n            { no: 1, name: \"pricings\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Pricing }\n        ]);\n    }\n    create(value?: PartialMessage<GetPricingsByProductResponse>): GetPricingsByProductResponse {\n        const message = { pricings: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetPricingsByProductResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPricingsByProductResponse): GetPricingsByProductResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Pricing pricings */ 1:\n                    message.pricings.push(Pricing.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetPricingsByProductResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Pricing pricings = 1; */\n        for (let i = 0; i < message.pricings.length; i++)\n            Pricing.internalBinaryWrite(message.pricings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetPricingsByProductResponse\n */\nexport const GetPricingsByProductResponse = new GetPricingsByProductResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertPricingRequest$Type extends MessageType<UpsertPricingRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertPricingRequest\", [\n            { no: 1, name: \"pricing\", kind: \"message\", T: () => Pricing }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertPricingRequest>): UpsertPricingRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertPricingRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertPricingRequest): UpsertPricingRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Pricing pricing */ 1:\n                    message.pricing = Pricing.internalBinaryRead(reader, reader.uint32(), options, message.pricing);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertPricingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Pricing pricing = 1; */\n        if (message.pricing)\n            Pricing.internalBinaryWrite(message.pricing, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertPricingRequest\n */\nexport const UpsertPricingRequest = new UpsertPricingRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertPricingResponse$Type extends MessageType<UpsertPricingResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertPricingResponse\", []);\n    }\n    create(value?: PartialMessage<UpsertPricingResponse>): UpsertPricingResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertPricingResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertPricingResponse): UpsertPricingResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: UpsertPricingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertPricingResponse\n */\nexport const UpsertPricingResponse = new UpsertPricingResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pricing$Type extends MessageType<Pricing> {\n    constructor() {\n        super(\"billing_platform.api.v1.Pricing\", [\n            { no: 1, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"price\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"meterType\", kind: \"enum\", T: () => [\"billing_platform.api.v1.PricingMeterType\", PricingMeterType] },\n            { no: 5, name: \"friendlyName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 6, name: \"azureMeterId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 7, name: \"effectiveDatePrices\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => HistoricalPrice },\n            { no: 8, name: \"freeForPublicRepos\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 9, name: \"effectiveAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 10, name: \"unitType\", kind: \"enum\", T: () => [\"billing_platform.base.UnitType\", UnitType] }\n        ]);\n    }\n    create(value?: PartialMessage<Pricing>): Pricing {\n        const message = { sku: \"\", product: \"\", price: 0, meterType: 0, friendlyName: \"\", azureMeterId: \"\", effectiveDatePrices: [], freeForPublicRepos: false, effectiveAt: \"0\", unitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Pricing>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pricing): Pricing {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 1:\n                    message.sku = reader.string();\n                    break;\n                case /* string product */ 2:\n                    message.product = reader.string();\n                    break;\n                case /* double price */ 3:\n                    message.price = reader.double();\n                    break;\n                case /* billing_platform.api.v1.PricingMeterType meterType */ 4:\n                    message.meterType = reader.int32();\n                    break;\n                case /* string friendlyName */ 5:\n                    message.friendlyName = reader.string();\n                    break;\n                case /* string azureMeterId */ 6:\n                    message.azureMeterId = reader.string();\n                    break;\n                case /* repeated billing_platform.api.v1.HistoricalPrice effectiveDatePrices */ 7:\n                    message.effectiveDatePrices.push(HistoricalPrice.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* bool freeForPublicRepos */ 8:\n                    message.freeForPublicRepos = reader.bool();\n                    break;\n                case /* int64 effectiveAt */ 9:\n                    message.effectiveAt = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.UnitType unitType */ 10:\n                    message.unitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Pricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 1; */\n        if (message.sku !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.sku);\n        /* string product = 2; */\n        if (message.product !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.product);\n        /* double price = 3; */\n        if (message.price !== 0)\n            writer.tag(3, WireType.Bit64).double(message.price);\n        /* billing_platform.api.v1.PricingMeterType meterType = 4; */\n        if (message.meterType !== 0)\n            writer.tag(4, WireType.Varint).int32(message.meterType);\n        /* string friendlyName = 5; */\n        if (message.friendlyName !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.friendlyName);\n        /* string azureMeterId = 6; */\n        if (message.azureMeterId !== \"\")\n            writer.tag(6, WireType.LengthDelimited).string(message.azureMeterId);\n        /* repeated billing_platform.api.v1.HistoricalPrice effectiveDatePrices = 7; */\n        for (let i = 0; i < message.effectiveDatePrices.length; i++)\n            HistoricalPrice.internalBinaryWrite(message.effectiveDatePrices[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();\n        /* bool freeForPublicRepos = 8; */\n        if (message.freeForPublicRepos !== false)\n            writer.tag(8, WireType.Varint).bool(message.freeForPublicRepos);\n        /* int64 effectiveAt = 9; */\n        if (message.effectiveAt !== \"0\")\n            writer.tag(9, WireType.Varint).int64(message.effectiveAt);\n        /* billing_platform.base.UnitType unitType = 10; */\n        if (message.unitType !== 0)\n            writer.tag(10, WireType.Varint).int32(message.unitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Pricing\n */\nexport const Pricing = new Pricing$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HistoricalPrice$Type extends MessageType<HistoricalPrice> {\n    constructor() {\n        super(\"billing_platform.api.v1.HistoricalPrice\", [\n            { no: 1, name: \"startDate\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 2, name: \"endDate\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"price\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ }\n        ]);\n    }\n    create(value?: PartialMessage<HistoricalPrice>): HistoricalPrice {\n        const message = { startDate: \"0\", endDate: \"0\", price: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<HistoricalPrice>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalPrice): HistoricalPrice {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int64 startDate */ 1:\n                    message.startDate = reader.int64().toString();\n                    break;\n                case /* int64 endDate */ 2:\n                    message.endDate = reader.int64().toString();\n                    break;\n                case /* double price */ 3:\n                    message.price = reader.double();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: HistoricalPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int64 startDate = 1; */\n        if (message.startDate !== \"0\")\n            writer.tag(1, WireType.Varint).int64(message.startDate);\n        /* int64 endDate = 2; */\n        if (message.endDate !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.endDate);\n        /* double price = 3; */\n        if (message.price !== 0)\n            writer.tag(3, WireType.Bit64).double(message.price);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.HistoricalPrice\n */\nexport const HistoricalPrice = new HistoricalPrice$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.PricingApi\n */\nexport const PricingApi = new ServiceType(\"billing_platform.api.v1.PricingApi\", [\n    { name: \"GetPricing\", options: {}, I: GetPricingRequest, O: GetPricingResponse },\n    { name: \"GetAllPricing\", options: {}, I: GetAllPricingRequest, O: GetAllPricingResponse },\n    { name: \"GetPricingsByProduct\", options: {}, I: GetPricingsByProductRequest, O: GetPricingsByProductResponse },\n    { name: \"UpsertPricing\", options: {}, I: UpsertPricingRequest, O: UpsertPricingResponse }\n]);\n" }, { path: "../ui/src/gen/proto/product-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/product-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { ProductApi } from \"./product-api\";\nimport type { UpsertProductResponse } from \"./product-api\";\nimport type { UpsertProductRequest } from \"./product-api\";\nimport type { GetProductResponse } from \"./product-api\";\nimport type { GetProductRequest } from \"./product-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { GetAllProductsResponse } from \"./product-api\";\nimport type { GetAllProductsRequest } from \"./product-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.ProductApi\n */\nexport interface IProductApiClient {\n    /**\n     * @generated from protobuf rpc: GetAllProducts(billing_platform.api.v1.GetAllProductsRequest) returns (billing_platform.api.v1.GetAllProductsResponse);\n     */\n    getAllProducts(input: GetAllProductsRequest, options?: RpcOptions): UnaryCall<GetAllProductsRequest, GetAllProductsResponse>;\n    /**\n     * @generated from protobuf rpc: GetProduct(billing_platform.api.v1.GetProductRequest) returns (billing_platform.api.v1.GetProductResponse);\n     */\n    getProduct(input: GetProductRequest, options?: RpcOptions): UnaryCall<GetProductRequest, GetProductResponse>;\n    /**\n     * @generated from protobuf rpc: UpsertProduct(billing_platform.api.v1.UpsertProductRequest) returns (billing_platform.api.v1.UpsertProductResponse);\n     */\n    upsertProduct(input: UpsertProductRequest, options?: RpcOptions): UnaryCall<UpsertProductRequest, UpsertProductResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.ProductApi\n */\nexport class ProductApiClient implements IProductApiClient, ServiceInfo {\n    typeName = ProductApi.typeName;\n    methods = ProductApi.methods;\n    options = ProductApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetAllProducts(billing_platform.api.v1.GetAllProductsRequest) returns (billing_platform.api.v1.GetAllProductsResponse);\n     */\n    getAllProducts(input: GetAllProductsRequest, options?: RpcOptions): UnaryCall<GetAllProductsRequest, GetAllProductsResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetAllProductsRequest, GetAllProductsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetProduct(billing_platform.api.v1.GetProductRequest) returns (billing_platform.api.v1.GetProductResponse);\n     */\n    getProduct(input: GetProductRequest, options?: RpcOptions): UnaryCall<GetProductRequest, GetProductResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetProductRequest, GetProductResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpsertProduct(billing_platform.api.v1.UpsertProductRequest) returns (billing_platform.api.v1.UpsertProductResponse);\n     */\n    upsertProduct(input: UpsertProductRequest, options?: RpcOptions): UnaryCall<UpsertProductRequest, UpsertProductResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpsertProductRequest, UpsertProductResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/product-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/product-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllProductsRequest\n */\nexport interface GetAllProductsRequest {\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetAllProductsResponse\n */\nexport interface GetAllProductsResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.Product products = 1;\n     */\n    products: Product[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetProductRequest\n */\nexport interface GetProductRequest {\n    /**\n     * @generated from protobuf field: string product = 2;\n     */\n    product: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetProductResponse\n */\nexport interface GetProductResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Product product = 1;\n     */\n    product?: Product;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertProductRequest\n */\nexport interface UpsertProductRequest {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Product product = 1;\n     */\n    product?: Product;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UpsertProductResponse\n */\nexport interface UpsertProductResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Product product = 1;\n     */\n    product?: Product;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Product\n */\nexport interface Product {\n    /**\n     * @generated from protobuf field: string name = 2;\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: string friendlyProductName = 3;\n     */\n    friendlyProductName: string;\n    /**\n     * @generated from protobuf field: string zuoraUsageIdentifier = 4;\n     */\n    zuoraUsageIdentifier: string;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllProductsRequest$Type extends MessageType<GetAllProductsRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllProductsRequest\", []);\n    }\n    create(value?: PartialMessage<GetAllProductsRequest>): GetAllProductsRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllProductsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllProductsRequest): GetAllProductsRequest {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: GetAllProductsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllProductsRequest\n */\nexport const GetAllProductsRequest = new GetAllProductsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetAllProductsResponse$Type extends MessageType<GetAllProductsResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetAllProductsResponse\", [\n            { no: 1, name: \"products\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Product }\n        ]);\n    }\n    create(value?: PartialMessage<GetAllProductsResponse>): GetAllProductsResponse {\n        const message = { products: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetAllProductsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllProductsResponse): GetAllProductsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.Product products */ 1:\n                    message.products.push(Product.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetAllProductsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.Product products = 1; */\n        for (let i = 0; i < message.products.length; i++)\n            Product.internalBinaryWrite(message.products[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetAllProductsResponse\n */\nexport const GetAllProductsResponse = new GetAllProductsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetProductRequest$Type extends MessageType<GetProductRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetProductRequest\", [\n            { no: 2, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetProductRequest>): GetProductRequest {\n        const message = { product: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetProductRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductRequest): GetProductRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string product */ 2:\n                    message.product = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetProductRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string product = 2; */\n        if (message.product !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.product);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetProductRequest\n */\nexport const GetProductRequest = new GetProductRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetProductResponse$Type extends MessageType<GetProductResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetProductResponse\", [\n            { no: 1, name: \"product\", kind: \"message\", T: () => Product }\n        ]);\n    }\n    create(value?: PartialMessage<GetProductResponse>): GetProductResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetProductResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductResponse): GetProductResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Product product */ 1:\n                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetProductResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Product product = 1; */\n        if (message.product)\n            Product.internalBinaryWrite(message.product, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetProductResponse\n */\nexport const GetProductResponse = new GetProductResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertProductRequest$Type extends MessageType<UpsertProductRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertProductRequest\", [\n            { no: 1, name: \"product\", kind: \"message\", T: () => Product }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertProductRequest>): UpsertProductRequest {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertProductRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertProductRequest): UpsertProductRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Product product */ 1:\n                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertProductRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Product product = 1; */\n        if (message.product)\n            Product.internalBinaryWrite(message.product, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertProductRequest\n */\nexport const UpsertProductRequest = new UpsertProductRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpsertProductResponse$Type extends MessageType<UpsertProductResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.UpsertProductResponse\", [\n            { no: 1, name: \"product\", kind: \"message\", T: () => Product }\n        ]);\n    }\n    create(value?: PartialMessage<UpsertProductResponse>): UpsertProductResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UpsertProductResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertProductResponse): UpsertProductResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Product product */ 1:\n                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpsertProductResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Product product = 1; */\n        if (message.product)\n            Product.internalBinaryWrite(message.product, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UpsertProductResponse\n */\nexport const UpsertProductResponse = new UpsertProductResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Product$Type extends MessageType<Product> {\n    constructor() {\n        super(\"billing_platform.api.v1.Product\", [\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"friendlyProductName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"zuoraUsageIdentifier\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Product>): Product {\n        const message = { name: \"\", friendlyProductName: \"\", zuoraUsageIdentifier: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Product>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Product): Product {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string friendlyProductName */ 3:\n                    message.friendlyProductName = reader.string();\n                    break;\n                case /* string zuoraUsageIdentifier */ 4:\n                    message.zuoraUsageIdentifier = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Product, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        /* string friendlyProductName = 3; */\n        if (message.friendlyProductName !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.friendlyProductName);\n        /* string zuoraUsageIdentifier = 4; */\n        if (message.zuoraUsageIdentifier !== \"\")\n            writer.tag(4, WireType.LengthDelimited).string(message.zuoraUsageIdentifier);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Product\n */\nexport const Product = new Product$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.ProductApi\n */\nexport const ProductApi = new ServiceType(\"billing_platform.api.v1.ProductApi\", [\n    { name: \"GetAllProducts\", options: {}, I: GetAllProductsRequest, O: GetAllProductsResponse },\n    { name: \"GetProduct\", options: {}, I: GetProductRequest, O: GetProductResponse },\n    { name: \"UpsertProduct\", options: {}, I: UpsertProductRequest, O: UpsertProductResponse }\n]);\n" }, { path: "../ui/src/gen/proto/usage-api.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/usage-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { UsageApi } from \"./usage-api\";\nimport type { GetWatermarkLevelResponse } from \"./usage-api\";\nimport type { GetWatermarkLevelRequest } from \"./usage-api\";\nimport type { GetRepoUsageResponse } from \"./usage-api\";\nimport type { GetRepoUsageRequest } from \"./usage-api\";\nimport type { GetInvoiceResponse } from \"./usage-api\";\nimport type { GetInvoiceRequest } from \"./usage-api\";\nimport type { GetDiscountLineItemsResponse } from \"./usage-api\";\nimport type { GetDiscountTotalResponse } from \"./usage-api\";\nimport type { GetUsageLineItemsResponse } from \"./usage-api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { GetUsageResponse } from \"./usage-api\";\nimport type { GetUsageRequest } from \"./usage-api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service billing_platform.api.v1.UsageApi\n */\nexport interface IUsageApiClient {\n    /**\n     * @generated from protobuf rpc: GetUsageTotal(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageResponse);\n     */\n    getUsageTotal(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageResponse>;\n    /**\n     * @generated from protobuf rpc: GetUsageLineItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageLineItemsResponse);\n     */\n    getUsageLineItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageLineItemsResponse>;\n    /**\n     * @generated from protobuf rpc: GetDiscountTotal(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetDiscountTotalResponse);\n     */\n    getDiscountTotal(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetDiscountTotalResponse>;\n    /**\n     * @generated from protobuf rpc: GetDiscountLineItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetDiscountLineItemsResponse);\n     */\n    getDiscountLineItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetDiscountLineItemsResponse>;\n    /**\n     * @generated from protobuf rpc: GetUsageEventItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageLineItemsResponse);\n     */\n    getUsageEventItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageLineItemsResponse>;\n    /**\n     * @generated from protobuf rpc: GetInvoice(billing_platform.api.v1.GetInvoiceRequest) returns (billing_platform.api.v1.GetInvoiceResponse);\n     */\n    getInvoice(input: GetInvoiceRequest, options?: RpcOptions): UnaryCall<GetInvoiceRequest, GetInvoiceResponse>;\n    /**\n     * @generated from protobuf rpc: GetRepoUsage(billing_platform.api.v1.GetRepoUsageRequest) returns (billing_platform.api.v1.GetRepoUsageResponse);\n     */\n    getRepoUsage(input: GetRepoUsageRequest, options?: RpcOptions): UnaryCall<GetRepoUsageRequest, GetRepoUsageResponse>;\n    /**\n     * @generated from protobuf rpc: GetWatermarkLevel(billing_platform.api.v1.GetWatermarkLevelRequest) returns (billing_platform.api.v1.GetWatermarkLevelResponse);\n     */\n    getWatermarkLevel(input: GetWatermarkLevelRequest, options?: RpcOptions): UnaryCall<GetWatermarkLevelRequest, GetWatermarkLevelResponse>;\n}\n/**\n * @generated from protobuf service billing_platform.api.v1.UsageApi\n */\nexport class UsageApiClient implements IUsageApiClient, ServiceInfo {\n    typeName = UsageApi.typeName;\n    methods = UsageApi.methods;\n    options = UsageApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetUsageTotal(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageResponse);\n     */\n    getUsageTotal(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetUsageRequest, GetUsageResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetUsageLineItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageLineItemsResponse);\n     */\n    getUsageLineItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageLineItemsResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetUsageRequest, GetUsageLineItemsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetDiscountTotal(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetDiscountTotalResponse);\n     */\n    getDiscountTotal(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetDiscountTotalResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetUsageRequest, GetDiscountTotalResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetDiscountLineItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetDiscountLineItemsResponse);\n     */\n    getDiscountLineItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetDiscountLineItemsResponse> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetUsageRequest, GetDiscountLineItemsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetUsageEventItems(billing_platform.api.v1.GetUsageRequest) returns (billing_platform.api.v1.GetUsageLineItemsResponse);\n     */\n    getUsageEventItems(input: GetUsageRequest, options?: RpcOptions): UnaryCall<GetUsageRequest, GetUsageLineItemsResponse> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetUsageRequest, GetUsageLineItemsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetInvoice(billing_platform.api.v1.GetInvoiceRequest) returns (billing_platform.api.v1.GetInvoiceResponse);\n     */\n    getInvoice(input: GetInvoiceRequest, options?: RpcOptions): UnaryCall<GetInvoiceRequest, GetInvoiceResponse> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetInvoiceRequest, GetInvoiceResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetRepoUsage(billing_platform.api.v1.GetRepoUsageRequest) returns (billing_platform.api.v1.GetRepoUsageResponse);\n     */\n    getRepoUsage(input: GetRepoUsageRequest, options?: RpcOptions): UnaryCall<GetRepoUsageRequest, GetRepoUsageResponse> {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetRepoUsageRequest, GetRepoUsageResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: GetWatermarkLevel(billing_platform.api.v1.GetWatermarkLevelRequest) returns (billing_platform.api.v1.GetWatermarkLevelResponse);\n     */\n    getWatermarkLevel(input: GetWatermarkLevelRequest, options?: RpcOptions): UnaryCall<GetWatermarkLevelRequest, GetWatermarkLevelResponse> {\n        const method = this.methods[7], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetWatermarkLevelRequest, GetWatermarkLevelResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "../ui/src/gen/proto/usage-api.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"proto/usage-api.proto\" (package \"billing_platform.api.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Key } from \"./base\";\nimport { UnitType } from \"./base\";\nimport { UsageGroupBy } from \"./base\";\nimport { BillingPeriod } from \"./base\";\n/**\n * @generated from protobuf message billing_platform.api.v1.GetUsageRequest\n */\nexport interface GetUsageRequest {\n    /**\n     * @generated from protobuf field: string usageEntityId = 1;\n     */\n    usageEntityId: string;\n    /**\n     * @generated from protobuf field: string product = 2;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: string sku = 3;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: int64 year = 4;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 5;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: int64 day = 6;\n     */\n    day: string;\n    /**\n     * @generated from protobuf field: int64 hour = 7;\n     */\n    hour: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.BillingPeriod billingPeriod = 8;\n     */\n    billingPeriod: BillingPeriod;\n    /**\n     * @generated from protobuf field: int64 repoId = 9;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: int64 orgId = 10;\n     */\n    orgId: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.UsageGroupBy groupBy = 11;\n     */\n    groupBy: UsageGroupBy;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetUsageResponse\n */\nexport interface GetUsageResponse {\n    /**\n     * @generated from protobuf field: string product = 1;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: double billableAmount = 4;\n     */\n    billableAmount: number;\n    /**\n     * @generated from protobuf field: bool hitCache = 5;\n     */\n    hitCache: boolean;\n    /**\n     * @generated from protobuf field: billing_platform.base.UnitType unitType = 6;\n     */\n    unitType: UnitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetUsageLineItemsResponse\n */\nexport interface GetUsageLineItemsResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.BillingItem billingItems = 1;\n     */\n    billingItems: BillingItem[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountLineItemsResponse\n */\nexport interface GetDiscountLineItemsResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.DiscountItem discountItems = 1;\n     */\n    discountItems: DiscountItem[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetDiscountTotalResponse\n */\nexport interface GetDiscountTotalResponse {\n    /**\n     * @generated from protobuf field: string product = 1;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: double discountAmount = 5;\n     */\n    discountAmount: number;\n    /**\n     * @generated from protobuf field: bool hitCache = 6;\n     */\n    hitCache: boolean;\n    /**\n     * @generated from protobuf field: billing_platform.base.UnitType unitType = 7;\n     */\n    unitType: UnitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetRepoUsageRequest\n */\nexport interface GetRepoUsageRequest {\n    /**\n     * @generated from protobuf field: string usageEntityId = 1;\n     */\n    usageEntityId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: int64 day = 4;\n     */\n    day: string;\n    /**\n     * @generated from protobuf field: int64 hour = 5;\n     */\n    hour: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.BillingPeriod billingPeriod = 6;\n     */\n    billingPeriod: BillingPeriod;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetRepoUsageResponse\n */\nexport interface GetRepoUsageResponse {\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.RepoUsage repoUsages = 1;\n     */\n    repoUsages: RepoUsage[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetInvoiceRequest\n */\nexport interface GetInvoiceRequest {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetInvoiceResponse\n */\nexport interface GetInvoiceResponse {\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.Invoice invoice = 1;\n     */\n    invoice?: Invoice;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetWatermarkLevelRequest\n */\nexport interface GetWatermarkLevelRequest {\n    /**\n     * @generated from protobuf field: string usageEntityId = 1;\n     */\n    usageEntityId: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: int64 repoId = 6;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: int64 orgId = 7;\n     */\n    orgId: string;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.GetWatermarkLevelResponse\n */\nexport interface GetWatermarkLevelResponse {\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.Invoice\n */\nexport interface Invoice {\n    /**\n     * @generated from protobuf field: string customerId = 1;\n     */\n    customerId: string;\n    /**\n     * @generated from protobuf field: int64 year = 2;\n     */\n    year: string;\n    /**\n     * @generated from protobuf field: int64 month = 3;\n     */\n    month: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.UsageTotal usageTotal = 4;\n     */\n    usageTotal?: UsageTotal;\n    /**\n     * @generated from protobuf field: map<string, billing_platform.api.v1.ProductTotal> ProductTotals = 5 [json_name = \"ProductTotals\"];\n     */\n    productTotals: {\n        [key: string]: ProductTotal;\n    };\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.ProductTotal\n */\nexport interface ProductTotal {\n    /**\n     * @generated from protobuf field: string product = 1;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.UsageTotal usageTotal = 2;\n     */\n    usageTotal?: UsageTotal;\n    /**\n     * @generated from protobuf field: map<string, billing_platform.api.v1.SkuTotal> SkuTotals = 3 [json_name = \"SkuTotals\"];\n     */\n    skuTotals: {\n        [key: string]: SkuTotal;\n    };\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.SkuTotal\n */\nexport interface SkuTotal {\n    /**\n     * @generated from protobuf field: string sku = 1;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: billing_platform.api.v1.UsageTotal usageTotal = 2;\n     */\n    usageTotal?: UsageTotal;\n    /**\n     * @generated from protobuf field: repeated billing_platform.api.v1.BillingItem billingItems = 3;\n     */\n    billingItems: BillingItem[];\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.UsageTotal\n */\nexport interface UsageTotal {\n    /**\n     * @generated from protobuf field: double gross = 1;\n     */\n    gross: number;\n    /**\n     * @generated from protobuf field: double discount = 2;\n     */\n    discount: number;\n    /**\n     * @generated from protobuf field: double net = 3;\n     */\n    net: number;\n    /**\n     * @generated from protobuf field: double quantity = 4;\n     */\n    quantity: number;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.DiscountItem\n */\nexport interface DiscountItem {\n    /**\n     * @generated from protobuf field: string sku = 1;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: string product = 2;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: double discountAmount = 4;\n     */\n    discountAmount: number;\n    /**\n     * @generated from protobuf field: int64 usageAt = 5;\n     */\n    usageAt: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.Key selfReference = 6;\n     */\n    selfReference?: Key;\n    /**\n     * @generated from protobuf field: billing_platform.base.UnitType unitType = 7;\n     */\n    unitType: UnitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.BillingItem\n */\nexport interface BillingItem {\n    /**\n     * @generated from protobuf field: string usageEntityId = 1;\n     */\n    usageEntityId: string;\n    /**\n     * @generated from protobuf field: string sku = 2;\n     */\n    sku: string;\n    /**\n     * @generated from protobuf field: string product = 3;\n     */\n    product: string;\n    /**\n     * @generated from protobuf field: double quantity = 4;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: double billedAmount = 5;\n     */\n    billedAmount: number;\n    /**\n     * @generated from protobuf field: double appliedCostPerQuantity = 6;\n     */\n    appliedCostPerQuantity: number;\n    /**\n     * @generated from protobuf field: int64 usageAt = 7;\n     */\n    usageAt: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.Key selfReference = 8;\n     */\n    selfReference?: Key;\n    /**\n     * @generated from protobuf field: string friendlySkuName = 9;\n     */\n    friendlySkuName: string;\n    /**\n     * @generated from protobuf field: int64 repoId = 10;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: int64 orgId = 11;\n     */\n    orgId: string;\n    /**\n     * @generated from protobuf field: billing_platform.base.UnitType unitType = 12;\n     */\n    unitType: UnitType;\n}\n/**\n * @generated from protobuf message billing_platform.api.v1.RepoUsage\n */\nexport interface RepoUsage {\n    /**\n     * @generated from protobuf field: int64 repoId = 1;\n     */\n    repoId: string;\n    /**\n     * @generated from protobuf field: int64 orgId = 2;\n     */\n    orgId: string;\n    /**\n     * @generated from protobuf field: double quantity = 3;\n     */\n    quantity: number;\n    /**\n     * @generated from protobuf field: double billedAmount = 4;\n     */\n    billedAmount: number;\n    /**\n     * @generated from protobuf field: billing_platform.base.Key selfReference = 5;\n     */\n    selfReference?: Key;\n    /**\n     * @generated from protobuf field: int64 usageAt = 6;\n     */\n    usageAt: string;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetUsageRequest$Type extends MessageType<GetUsageRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetUsageRequest\", [\n            { no: 1, name: \"usageEntityId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 6, name: \"day\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 7, name: \"hour\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 8, name: \"billingPeriod\", kind: \"enum\", T: () => [\"billing_platform.base.BillingPeriod\", BillingPeriod] },\n            { no: 9, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 10, name: \"orgId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 11, name: \"groupBy\", kind: \"enum\", T: () => [\"billing_platform.base.UsageGroupBy\", UsageGroupBy] }\n        ]);\n    }\n    create(value?: PartialMessage<GetUsageRequest>): GetUsageRequest {\n        const message = { usageEntityId: \"\", product: \"\", sku: \"\", year: \"0\", month: \"0\", day: \"0\", hour: \"0\", billingPeriod: 0, repoId: \"0\", orgId: \"0\", groupBy: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetUsageRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUsageRequest): GetUsageRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string usageEntityId */ 1:\n                    message.usageEntityId = reader.string();\n                    break;\n                case /* string product */ 2:\n                    message.product = reader.string();\n                    break;\n                case /* string sku */ 3:\n                    message.sku = reader.string();\n                    break;\n                case /* int64 year */ 4:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 5:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* int64 day */ 6:\n                    message.day = reader.int64().toString();\n                    break;\n                case /* int64 hour */ 7:\n                    message.hour = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.BillingPeriod billingPeriod */ 8:\n                    message.billingPeriod = reader.int32();\n                    break;\n                case /* int64 repoId */ 9:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* int64 orgId */ 10:\n                    message.orgId = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.UsageGroupBy groupBy */ 11:\n                    message.groupBy = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetUsageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string usageEntityId = 1; */\n        if (message.usageEntityId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.usageEntityId);\n        /* string product = 2; */\n        if (message.product !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.product);\n        /* string sku = 3; */\n        if (message.sku !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.sku);\n        /* int64 year = 4; */\n        if (message.year !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.year);\n        /* int64 month = 5; */\n        if (message.month !== \"0\")\n            writer.tag(5, WireType.Varint).int64(message.month);\n        /* int64 day = 6; */\n        if (message.day !== \"0\")\n            writer.tag(6, WireType.Varint).int64(message.day);\n        /* int64 hour = 7; */\n        if (message.hour !== \"0\")\n            writer.tag(7, WireType.Varint).int64(message.hour);\n        /* billing_platform.base.BillingPeriod billingPeriod = 8; */\n        if (message.billingPeriod !== 0)\n            writer.tag(8, WireType.Varint).int32(message.billingPeriod);\n        /* int64 repoId = 9; */\n        if (message.repoId !== \"0\")\n            writer.tag(9, WireType.Varint).int64(message.repoId);\n        /* int64 orgId = 10; */\n        if (message.orgId !== \"0\")\n            writer.tag(10, WireType.Varint).int64(message.orgId);\n        /* billing_platform.base.UsageGroupBy groupBy = 11; */\n        if (message.groupBy !== 0)\n            writer.tag(11, WireType.Varint).int32(message.groupBy);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetUsageRequest\n */\nexport const GetUsageRequest = new GetUsageRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetUsageResponse$Type extends MessageType<GetUsageResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetUsageResponse\", [\n            { no: 1, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"billableAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"hitCache\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 6, name: \"unitType\", kind: \"enum\", T: () => [\"billing_platform.base.UnitType\", UnitType] }\n        ]);\n    }\n    create(value?: PartialMessage<GetUsageResponse>): GetUsageResponse {\n        const message = { product: \"\", sku: \"\", quantity: 0, billableAmount: 0, hitCache: false, unitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetUsageResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUsageResponse): GetUsageResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string product */ 1:\n                    message.product = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                case /* double billableAmount */ 4:\n                    message.billableAmount = reader.double();\n                    break;\n                case /* bool hitCache */ 5:\n                    message.hitCache = reader.bool();\n                    break;\n                case /* billing_platform.base.UnitType unitType */ 6:\n                    message.unitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetUsageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string product = 1; */\n        if (message.product !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.product);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        /* double billableAmount = 4; */\n        if (message.billableAmount !== 0)\n            writer.tag(4, WireType.Bit64).double(message.billableAmount);\n        /* bool hitCache = 5; */\n        if (message.hitCache !== false)\n            writer.tag(5, WireType.Varint).bool(message.hitCache);\n        /* billing_platform.base.UnitType unitType = 6; */\n        if (message.unitType !== 0)\n            writer.tag(6, WireType.Varint).int32(message.unitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetUsageResponse\n */\nexport const GetUsageResponse = new GetUsageResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetUsageLineItemsResponse$Type extends MessageType<GetUsageLineItemsResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetUsageLineItemsResponse\", [\n            { no: 1, name: \"billingItems\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => BillingItem }\n        ]);\n    }\n    create(value?: PartialMessage<GetUsageLineItemsResponse>): GetUsageLineItemsResponse {\n        const message = { billingItems: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetUsageLineItemsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUsageLineItemsResponse): GetUsageLineItemsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.BillingItem billingItems */ 1:\n                    message.billingItems.push(BillingItem.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetUsageLineItemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.BillingItem billingItems = 1; */\n        for (let i = 0; i < message.billingItems.length; i++)\n            BillingItem.internalBinaryWrite(message.billingItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetUsageLineItemsResponse\n */\nexport const GetUsageLineItemsResponse = new GetUsageLineItemsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountLineItemsResponse$Type extends MessageType<GetDiscountLineItemsResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountLineItemsResponse\", [\n            { no: 1, name: \"discountItems\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => DiscountItem }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountLineItemsResponse>): GetDiscountLineItemsResponse {\n        const message = { discountItems: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountLineItemsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountLineItemsResponse): GetDiscountLineItemsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.DiscountItem discountItems */ 1:\n                    message.discountItems.push(DiscountItem.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountLineItemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.DiscountItem discountItems = 1; */\n        for (let i = 0; i < message.discountItems.length; i++)\n            DiscountItem.internalBinaryWrite(message.discountItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountLineItemsResponse\n */\nexport const GetDiscountLineItemsResponse = new GetDiscountLineItemsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetDiscountTotalResponse$Type extends MessageType<GetDiscountTotalResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetDiscountTotalResponse\", [\n            { no: 1, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"discountAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 6, name: \"hitCache\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 7, name: \"unitType\", kind: \"enum\", T: () => [\"billing_platform.base.UnitType\", UnitType] }\n        ]);\n    }\n    create(value?: PartialMessage<GetDiscountTotalResponse>): GetDiscountTotalResponse {\n        const message = { product: \"\", sku: \"\", quantity: 0, discountAmount: 0, hitCache: false, unitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetDiscountTotalResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscountTotalResponse): GetDiscountTotalResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string product */ 1:\n                    message.product = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                case /* double discountAmount */ 5:\n                    message.discountAmount = reader.double();\n                    break;\n                case /* bool hitCache */ 6:\n                    message.hitCache = reader.bool();\n                    break;\n                case /* billing_platform.base.UnitType unitType */ 7:\n                    message.unitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetDiscountTotalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string product = 1; */\n        if (message.product !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.product);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        /* double discountAmount = 5; */\n        if (message.discountAmount !== 0)\n            writer.tag(5, WireType.Bit64).double(message.discountAmount);\n        /* bool hitCache = 6; */\n        if (message.hitCache !== false)\n            writer.tag(6, WireType.Varint).bool(message.hitCache);\n        /* billing_platform.base.UnitType unitType = 7; */\n        if (message.unitType !== 0)\n            writer.tag(7, WireType.Varint).int32(message.unitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetDiscountTotalResponse\n */\nexport const GetDiscountTotalResponse = new GetDiscountTotalResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetRepoUsageRequest$Type extends MessageType<GetRepoUsageRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetRepoUsageRequest\", [\n            { no: 1, name: \"usageEntityId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"day\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 5, name: \"hour\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 6, name: \"billingPeriod\", kind: \"enum\", T: () => [\"billing_platform.base.BillingPeriod\", BillingPeriod] }\n        ]);\n    }\n    create(value?: PartialMessage<GetRepoUsageRequest>): GetRepoUsageRequest {\n        const message = { usageEntityId: \"\", year: \"0\", month: \"0\", day: \"0\", hour: \"0\", billingPeriod: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetRepoUsageRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRepoUsageRequest): GetRepoUsageRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string usageEntityId */ 1:\n                    message.usageEntityId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* int64 day */ 4:\n                    message.day = reader.int64().toString();\n                    break;\n                case /* int64 hour */ 5:\n                    message.hour = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.BillingPeriod billingPeriod */ 6:\n                    message.billingPeriod = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetRepoUsageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string usageEntityId = 1; */\n        if (message.usageEntityId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.usageEntityId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        /* int64 day = 4; */\n        if (message.day !== \"0\")\n            writer.tag(4, WireType.Varint).int64(message.day);\n        /* int64 hour = 5; */\n        if (message.hour !== \"0\")\n            writer.tag(5, WireType.Varint).int64(message.hour);\n        /* billing_platform.base.BillingPeriod billingPeriod = 6; */\n        if (message.billingPeriod !== 0)\n            writer.tag(6, WireType.Varint).int32(message.billingPeriod);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetRepoUsageRequest\n */\nexport const GetRepoUsageRequest = new GetRepoUsageRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetRepoUsageResponse$Type extends MessageType<GetRepoUsageResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetRepoUsageResponse\", [\n            { no: 1, name: \"repoUsages\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => RepoUsage }\n        ]);\n    }\n    create(value?: PartialMessage<GetRepoUsageResponse>): GetRepoUsageResponse {\n        const message = { repoUsages: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetRepoUsageResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRepoUsageResponse): GetRepoUsageResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated billing_platform.api.v1.RepoUsage repoUsages */ 1:\n                    message.repoUsages.push(RepoUsage.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetRepoUsageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated billing_platform.api.v1.RepoUsage repoUsages = 1; */\n        for (let i = 0; i < message.repoUsages.length; i++)\n            RepoUsage.internalBinaryWrite(message.repoUsages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetRepoUsageResponse\n */\nexport const GetRepoUsageResponse = new GetRepoUsageResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetInvoiceRequest$Type extends MessageType<GetInvoiceRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetInvoiceRequest\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetInvoiceRequest>): GetInvoiceRequest {\n        const message = { customerId: \"\", year: \"0\", month: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetInvoiceRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoiceRequest): GetInvoiceRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetInvoiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetInvoiceRequest\n */\nexport const GetInvoiceRequest = new GetInvoiceRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetInvoiceResponse$Type extends MessageType<GetInvoiceResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetInvoiceResponse\", [\n            { no: 1, name: \"invoice\", kind: \"message\", T: () => Invoice }\n        ]);\n    }\n    create(value?: PartialMessage<GetInvoiceResponse>): GetInvoiceResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetInvoiceResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvoiceResponse): GetInvoiceResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* billing_platform.api.v1.Invoice invoice */ 1:\n                    message.invoice = Invoice.internalBinaryRead(reader, reader.uint32(), options, message.invoice);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetInvoiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* billing_platform.api.v1.Invoice invoice = 1; */\n        if (message.invoice)\n            Invoice.internalBinaryWrite(message.invoice, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetInvoiceResponse\n */\nexport const GetInvoiceResponse = new GetInvoiceResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetWatermarkLevelRequest$Type extends MessageType<GetWatermarkLevelRequest> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetWatermarkLevelRequest\", [\n            { no: 1, name: \"usageEntityId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 6, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 7, name: \"orgId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetWatermarkLevelRequest>): GetWatermarkLevelRequest {\n        const message = { usageEntityId: \"\", sku: \"\", repoId: \"0\", orgId: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetWatermarkLevelRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWatermarkLevelRequest): GetWatermarkLevelRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string usageEntityId */ 1:\n                    message.usageEntityId = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* int64 repoId */ 6:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* int64 orgId */ 7:\n                    message.orgId = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetWatermarkLevelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string usageEntityId = 1; */\n        if (message.usageEntityId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.usageEntityId);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* int64 repoId = 6; */\n        if (message.repoId !== \"0\")\n            writer.tag(6, WireType.Varint).int64(message.repoId);\n        /* int64 orgId = 7; */\n        if (message.orgId !== \"0\")\n            writer.tag(7, WireType.Varint).int64(message.orgId);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetWatermarkLevelRequest\n */\nexport const GetWatermarkLevelRequest = new GetWatermarkLevelRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetWatermarkLevelResponse$Type extends MessageType<GetWatermarkLevelResponse> {\n    constructor() {\n        super(\"billing_platform.api.v1.GetWatermarkLevelResponse\", [\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetWatermarkLevelResponse>): GetWatermarkLevelResponse {\n        const message = { sku: \"\", quantity: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<GetWatermarkLevelResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWatermarkLevelResponse): GetWatermarkLevelResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetWatermarkLevelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.GetWatermarkLevelResponse\n */\nexport const GetWatermarkLevelResponse = new GetWatermarkLevelResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Invoice$Type extends MessageType<Invoice> {\n    constructor() {\n        super(\"billing_platform.api.v1.Invoice\", [\n            { no: 1, name: \"customerId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"year\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"month\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 4, name: \"usageTotal\", kind: \"message\", T: () => UsageTotal },\n            { no: 5, name: \"ProductTotals\", kind: \"map\", jsonName: \"ProductTotals\", K: 9 /*ScalarType.STRING*/, V: { kind: \"message\", T: () => ProductTotal } }\n        ]);\n    }\n    create(value?: PartialMessage<Invoice>): Invoice {\n        const message = { customerId: \"\", year: \"0\", month: \"0\", productTotals: {} };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Invoice>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Invoice): Invoice {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string customerId */ 1:\n                    message.customerId = reader.string();\n                    break;\n                case /* int64 year */ 2:\n                    message.year = reader.int64().toString();\n                    break;\n                case /* int64 month */ 3:\n                    message.month = reader.int64().toString();\n                    break;\n                case /* billing_platform.api.v1.UsageTotal usageTotal */ 4:\n                    message.usageTotal = UsageTotal.internalBinaryRead(reader, reader.uint32(), options, message.usageTotal);\n                    break;\n                case /* map<string, billing_platform.api.v1.ProductTotal> ProductTotals = 5 [json_name = \"ProductTotals\"];*/ 5:\n                    this.binaryReadMap5(message.productTotals, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    private binaryReadMap5(map: Invoice[\"productTotals\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof Invoice[\"productTotals\"] | undefined, val: Invoice[\"productTotals\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = ProductTotal.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field billing_platform.api.v1.Invoice.ProductTotals\");\n            }\n        }\n        map[key ?? \"\"] = val ?? ProductTotal.create();\n    }\n    internalBinaryWrite(message: Invoice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string customerId = 1; */\n        if (message.customerId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.customerId);\n        /* int64 year = 2; */\n        if (message.year !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.year);\n        /* int64 month = 3; */\n        if (message.month !== \"0\")\n            writer.tag(3, WireType.Varint).int64(message.month);\n        /* billing_platform.api.v1.UsageTotal usageTotal = 4; */\n        if (message.usageTotal)\n            UsageTotal.internalBinaryWrite(message.usageTotal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        /* map<string, billing_platform.api.v1.ProductTotal> ProductTotals = 5 [json_name = \"ProductTotals\"]; */\n        for (let k of Object.keys(message.productTotals)) {\n            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);\n            writer.tag(2, WireType.LengthDelimited).fork();\n            ProductTotal.internalBinaryWrite(message.productTotals[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.Invoice\n */\nexport const Invoice = new Invoice$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ProductTotal$Type extends MessageType<ProductTotal> {\n    constructor() {\n        super(\"billing_platform.api.v1.ProductTotal\", [\n            { no: 1, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"usageTotal\", kind: \"message\", T: () => UsageTotal },\n            { no: 3, name: \"SkuTotals\", kind: \"map\", jsonName: \"SkuTotals\", K: 9 /*ScalarType.STRING*/, V: { kind: \"message\", T: () => SkuTotal } }\n        ]);\n    }\n    create(value?: PartialMessage<ProductTotal>): ProductTotal {\n        const message = { product: \"\", skuTotals: {} };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<ProductTotal>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductTotal): ProductTotal {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string product */ 1:\n                    message.product = reader.string();\n                    break;\n                case /* billing_platform.api.v1.UsageTotal usageTotal */ 2:\n                    message.usageTotal = UsageTotal.internalBinaryRead(reader, reader.uint32(), options, message.usageTotal);\n                    break;\n                case /* map<string, billing_platform.api.v1.SkuTotal> SkuTotals = 3 [json_name = \"SkuTotals\"];*/ 3:\n                    this.binaryReadMap3(message.skuTotals, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    private binaryReadMap3(map: ProductTotal[\"skuTotals\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof ProductTotal[\"skuTotals\"] | undefined, val: ProductTotal[\"skuTotals\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = SkuTotal.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field billing_platform.api.v1.ProductTotal.SkuTotals\");\n            }\n        }\n        map[key ?? \"\"] = val ?? SkuTotal.create();\n    }\n    internalBinaryWrite(message: ProductTotal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string product = 1; */\n        if (message.product !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.product);\n        /* billing_platform.api.v1.UsageTotal usageTotal = 2; */\n        if (message.usageTotal)\n            UsageTotal.internalBinaryWrite(message.usageTotal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* map<string, billing_platform.api.v1.SkuTotal> SkuTotals = 3 [json_name = \"SkuTotals\"]; */\n        for (let k of Object.keys(message.skuTotals)) {\n            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);\n            writer.tag(2, WireType.LengthDelimited).fork();\n            SkuTotal.internalBinaryWrite(message.skuTotals[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.ProductTotal\n */\nexport const ProductTotal = new ProductTotal$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SkuTotal$Type extends MessageType<SkuTotal> {\n    constructor() {\n        super(\"billing_platform.api.v1.SkuTotal\", [\n            { no: 1, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"usageTotal\", kind: \"message\", T: () => UsageTotal },\n            { no: 3, name: \"billingItems\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => BillingItem }\n        ]);\n    }\n    create(value?: PartialMessage<SkuTotal>): SkuTotal {\n        const message = { sku: \"\", billingItems: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<SkuTotal>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkuTotal): SkuTotal {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 1:\n                    message.sku = reader.string();\n                    break;\n                case /* billing_platform.api.v1.UsageTotal usageTotal */ 2:\n                    message.usageTotal = UsageTotal.internalBinaryRead(reader, reader.uint32(), options, message.usageTotal);\n                    break;\n                case /* repeated billing_platform.api.v1.BillingItem billingItems */ 3:\n                    message.billingItems.push(BillingItem.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SkuTotal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 1; */\n        if (message.sku !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.sku);\n        /* billing_platform.api.v1.UsageTotal usageTotal = 2; */\n        if (message.usageTotal)\n            UsageTotal.internalBinaryWrite(message.usageTotal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* repeated billing_platform.api.v1.BillingItem billingItems = 3; */\n        for (let i = 0; i < message.billingItems.length; i++)\n            BillingItem.internalBinaryWrite(message.billingItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.SkuTotal\n */\nexport const SkuTotal = new SkuTotal$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UsageTotal$Type extends MessageType<UsageTotal> {\n    constructor() {\n        super(\"billing_platform.api.v1.UsageTotal\", [\n            { no: 1, name: \"gross\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 2, name: \"discount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 3, name: \"net\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ }\n        ]);\n    }\n    create(value?: PartialMessage<UsageTotal>): UsageTotal {\n        const message = { gross: 0, discount: 0, net: 0, quantity: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<UsageTotal>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageTotal): UsageTotal {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* double gross */ 1:\n                    message.gross = reader.double();\n                    break;\n                case /* double discount */ 2:\n                    message.discount = reader.double();\n                    break;\n                case /* double net */ 3:\n                    message.net = reader.double();\n                    break;\n                case /* double quantity */ 4:\n                    message.quantity = reader.double();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UsageTotal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* double gross = 1; */\n        if (message.gross !== 0)\n            writer.tag(1, WireType.Bit64).double(message.gross);\n        /* double discount = 2; */\n        if (message.discount !== 0)\n            writer.tag(2, WireType.Bit64).double(message.discount);\n        /* double net = 3; */\n        if (message.net !== 0)\n            writer.tag(3, WireType.Bit64).double(message.net);\n        /* double quantity = 4; */\n        if (message.quantity !== 0)\n            writer.tag(4, WireType.Bit64).double(message.quantity);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.UsageTotal\n */\nexport const UsageTotal = new UsageTotal$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DiscountItem$Type extends MessageType<DiscountItem> {\n    constructor() {\n        super(\"billing_platform.api.v1.DiscountItem\", [\n            { no: 1, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"discountAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"usageAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 6, name: \"selfReference\", kind: \"message\", T: () => Key },\n            { no: 7, name: \"unitType\", kind: \"enum\", T: () => [\"billing_platform.base.UnitType\", UnitType] }\n        ]);\n    }\n    create(value?: PartialMessage<DiscountItem>): DiscountItem {\n        const message = { sku: \"\", product: \"\", quantity: 0, discountAmount: 0, usageAt: \"0\", unitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<DiscountItem>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscountItem): DiscountItem {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string sku */ 1:\n                    message.sku = reader.string();\n                    break;\n                case /* string product */ 2:\n                    message.product = reader.string();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                case /* double discountAmount */ 4:\n                    message.discountAmount = reader.double();\n                    break;\n                case /* int64 usageAt */ 5:\n                    message.usageAt = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.Key selfReference */ 6:\n                    message.selfReference = Key.internalBinaryRead(reader, reader.uint32(), options, message.selfReference);\n                    break;\n                case /* billing_platform.base.UnitType unitType */ 7:\n                    message.unitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: DiscountItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string sku = 1; */\n        if (message.sku !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.sku);\n        /* string product = 2; */\n        if (message.product !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.product);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        /* double discountAmount = 4; */\n        if (message.discountAmount !== 0)\n            writer.tag(4, WireType.Bit64).double(message.discountAmount);\n        /* int64 usageAt = 5; */\n        if (message.usageAt !== \"0\")\n            writer.tag(5, WireType.Varint).int64(message.usageAt);\n        /* billing_platform.base.Key selfReference = 6; */\n        if (message.selfReference)\n            Key.internalBinaryWrite(message.selfReference, writer.tag(6, WireType.LengthDelimited).fork(), options).join();\n        /* billing_platform.base.UnitType unitType = 7; */\n        if (message.unitType !== 0)\n            writer.tag(7, WireType.Varint).int32(message.unitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.DiscountItem\n */\nexport const DiscountItem = new DiscountItem$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BillingItem$Type extends MessageType<BillingItem> {\n    constructor() {\n        super(\"billing_platform.api.v1.BillingItem\", [\n            { no: 1, name: \"usageEntityId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"sku\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"product\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"billedAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 6, name: \"appliedCostPerQuantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 7, name: \"usageAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 8, name: \"selfReference\", kind: \"message\", T: () => Key },\n            { no: 9, name: \"friendlySkuName\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 10, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 11, name: \"orgId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 12, name: \"unitType\", kind: \"enum\", T: () => [\"billing_platform.base.UnitType\", UnitType] }\n        ]);\n    }\n    create(value?: PartialMessage<BillingItem>): BillingItem {\n        const message = { usageEntityId: \"\", sku: \"\", product: \"\", quantity: 0, billedAmount: 0, appliedCostPerQuantity: 0, usageAt: \"0\", friendlySkuName: \"\", repoId: \"0\", orgId: \"0\", unitType: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<BillingItem>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BillingItem): BillingItem {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string usageEntityId */ 1:\n                    message.usageEntityId = reader.string();\n                    break;\n                case /* string sku */ 2:\n                    message.sku = reader.string();\n                    break;\n                case /* string product */ 3:\n                    message.product = reader.string();\n                    break;\n                case /* double quantity */ 4:\n                    message.quantity = reader.double();\n                    break;\n                case /* double billedAmount */ 5:\n                    message.billedAmount = reader.double();\n                    break;\n                case /* double appliedCostPerQuantity */ 6:\n                    message.appliedCostPerQuantity = reader.double();\n                    break;\n                case /* int64 usageAt */ 7:\n                    message.usageAt = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.Key selfReference */ 8:\n                    message.selfReference = Key.internalBinaryRead(reader, reader.uint32(), options, message.selfReference);\n                    break;\n                case /* string friendlySkuName */ 9:\n                    message.friendlySkuName = reader.string();\n                    break;\n                case /* int64 repoId */ 10:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* int64 orgId */ 11:\n                    message.orgId = reader.int64().toString();\n                    break;\n                case /* billing_platform.base.UnitType unitType */ 12:\n                    message.unitType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: BillingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string usageEntityId = 1; */\n        if (message.usageEntityId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.usageEntityId);\n        /* string sku = 2; */\n        if (message.sku !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.sku);\n        /* string product = 3; */\n        if (message.product !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.product);\n        /* double quantity = 4; */\n        if (message.quantity !== 0)\n            writer.tag(4, WireType.Bit64).double(message.quantity);\n        /* double billedAmount = 5; */\n        if (message.billedAmount !== 0)\n            writer.tag(5, WireType.Bit64).double(message.billedAmount);\n        /* double appliedCostPerQuantity = 6; */\n        if (message.appliedCostPerQuantity !== 0)\n            writer.tag(6, WireType.Bit64).double(message.appliedCostPerQuantity);\n        /* int64 usageAt = 7; */\n        if (message.usageAt !== \"0\")\n            writer.tag(7, WireType.Varint).int64(message.usageAt);\n        /* billing_platform.base.Key selfReference = 8; */\n        if (message.selfReference)\n            Key.internalBinaryWrite(message.selfReference, writer.tag(8, WireType.LengthDelimited).fork(), options).join();\n        /* string friendlySkuName = 9; */\n        if (message.friendlySkuName !== \"\")\n            writer.tag(9, WireType.LengthDelimited).string(message.friendlySkuName);\n        /* int64 repoId = 10; */\n        if (message.repoId !== \"0\")\n            writer.tag(10, WireType.Varint).int64(message.repoId);\n        /* int64 orgId = 11; */\n        if (message.orgId !== \"0\")\n            writer.tag(11, WireType.Varint).int64(message.orgId);\n        /* billing_platform.base.UnitType unitType = 12; */\n        if (message.unitType !== 0)\n            writer.tag(12, WireType.Varint).int32(message.unitType);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.BillingItem\n */\nexport const BillingItem = new BillingItem$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RepoUsage$Type extends MessageType<RepoUsage> {\n    constructor() {\n        super(\"billing_platform.api.v1.RepoUsage\", [\n            { no: 1, name: \"repoId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 2, name: \"orgId\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 3, name: \"quantity\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 4, name: \"billedAmount\", kind: \"scalar\", T: 1 /*ScalarType.DOUBLE*/ },\n            { no: 5, name: \"selfReference\", kind: \"message\", T: () => Key },\n            { no: 6, name: \"usageAt\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<RepoUsage>): RepoUsage {\n        const message = { repoId: \"0\", orgId: \"0\", quantity: 0, billedAmount: 0, usageAt: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<RepoUsage>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepoUsage): RepoUsage {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int64 repoId */ 1:\n                    message.repoId = reader.int64().toString();\n                    break;\n                case /* int64 orgId */ 2:\n                    message.orgId = reader.int64().toString();\n                    break;\n                case /* double quantity */ 3:\n                    message.quantity = reader.double();\n                    break;\n                case /* double billedAmount */ 4:\n                    message.billedAmount = reader.double();\n                    break;\n                case /* billing_platform.base.Key selfReference */ 5:\n                    message.selfReference = Key.internalBinaryRead(reader, reader.uint32(), options, message.selfReference);\n                    break;\n                case /* int64 usageAt */ 6:\n                    message.usageAt = reader.int64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RepoUsage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int64 repoId = 1; */\n        if (message.repoId !== \"0\")\n            writer.tag(1, WireType.Varint).int64(message.repoId);\n        /* int64 orgId = 2; */\n        if (message.orgId !== \"0\")\n            writer.tag(2, WireType.Varint).int64(message.orgId);\n        /* double quantity = 3; */\n        if (message.quantity !== 0)\n            writer.tag(3, WireType.Bit64).double(message.quantity);\n        /* double billedAmount = 4; */\n        if (message.billedAmount !== 0)\n            writer.tag(4, WireType.Bit64).double(message.billedAmount);\n        /* billing_platform.base.Key selfReference = 5; */\n        if (message.selfReference)\n            Key.internalBinaryWrite(message.selfReference, writer.tag(5, WireType.LengthDelimited).fork(), options).join();\n        /* int64 usageAt = 6; */\n        if (message.usageAt !== \"0\")\n            writer.tag(6, WireType.Varint).int64(message.usageAt);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message billing_platform.api.v1.RepoUsage\n */\nexport const RepoUsage = new RepoUsage$Type();\n/**\n * @generated ServiceType for protobuf service billing_platform.api.v1.UsageApi\n */\nexport const UsageApi = new ServiceType(\"billing_platform.api.v1.UsageApi\", [\n    { name: \"GetUsageTotal\", options: {}, I: GetUsageRequest, O: GetUsageResponse },\n    { name: \"GetUsageLineItems\", options: {}, I: GetUsageRequest, O: GetUsageLineItemsResponse },\n    { name: \"GetDiscountTotal\", options: {}, I: GetUsageRequest, O: GetDiscountTotalResponse },\n    { name: \"GetDiscountLineItems\", options: {}, I: GetUsageRequest, O: GetDiscountLineItemsResponse },\n    { name: \"GetUsageEventItems\", options: {}, I: GetUsageRequest, O: GetUsageLineItemsResponse },\n    { name: \"GetInvoice\", options: {}, I: GetInvoiceRequest, O: GetInvoiceResponse },\n    { name: \"GetRepoUsage\", options: {}, I: GetRepoUsageRequest, O: GetRepoUsageResponse },\n    { name: \"GetWatermarkLevel\", options: {}, I: GetWatermarkLevelRequest, O: GetWatermarkLevelResponse }\n]);\n" }] };
export function getClient(name: string, transport: RpcTransport): ServiceInfo | undefined { switch (name) {
    case "AdminApiClient": return new AdminApiClient(transport);
    case "CostCenterApiClient": return new CostCenterApiClient(transport);
    case "CustomerApiClient": return new CustomerApiClient(transport);
    case "InvoiceAPIClient": return new InvoiceAPIClient(transport);
    case "PricingApiClient": return new PricingApiClient(transport);
    case "ProductApiClient": return new ProductApiClient(transport);
    case "UsageApiClient": return new UsageApiClient(transport);
} return undefined; }
