import { QuirksClient } from "./quirks.client";
import { SearchServiceClient } from "./search-service.client";
import { RpcTransport, ServiceInfo } from "@protobuf-ts/runtime-rpc";
export const model = { gens: [{ path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/.gitignore", content: "**/*.ts\n!kt.ts" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/google/protobuf/timestamp.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"google/protobuf/timestamp.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport { PbLong } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n *\n * @generated from protobuf message google.protobuf.Timestamp\n */\nexport interface Timestamp {\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from protobuf field: int64 seconds = 1;\n     */\n    seconds: string;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from protobuf field: int32 nanos = 2;\n     */\n    nanos: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends MessageType<Timestamp> {\n    constructor() {\n        super(\"google.protobuf.Timestamp\", [\n            { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/ },\n            { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */\n    now(): Timestamp {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */\n    toDate(message: Timestamp): Date {\n        return new Date(PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */\n    fromDate(date: Date): Timestamp {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonWrite(message: Timestamp, options: JsonWriteOptions): JsonValue {\n        let ms = PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0)\n            throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\")\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\")\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else\n                z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Timestamp): Timestamp {\n        if (typeof json !== \"string\")\n            throw new Error(\"Unable to parse Timestamp from JSON \" + typeofJsonValue(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches)\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms))\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target)\n            target = this.create();\n        target.seconds = PbLong.from(ms / 1000).toString();\n        target.nanos = 0;\n        if (matches[7])\n            target.nanos = (parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000);\n        return target;\n    }\n    create(value?: PartialMessage<Timestamp>): Timestamp {\n        const message = { seconds: \"0\", nanos: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Timestamp>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Timestamp): Timestamp {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toString();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int64 seconds = 1; */\n        if (message.seconds !== \"0\")\n            writer.tag(1, WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */\n        if (message.nanos !== 0)\n            writer.tag(2, WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */\nexport const Timestamp = new Timestamp$Type();\n" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/lib/message.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"lib/message.proto\" (package \"lib\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message lib.Message\n */\nexport interface Message {\n    /**\n     * @generated from protobuf field: string name = 1;\n     */\n    name: string;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Message$Type extends MessageType<Message> {\n    constructor() {\n        super(\"lib.Message\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Message>): Message {\n        const message = { name: \"\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Message>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message lib.Message\n */\nexport const Message = new Message$Type();\n" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/quirks.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"quirks.proto\" (package \"quirks.v1\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { Quirks } from \"./quirks\";\nimport type { TypesRequest } from \"./quirks\";\nimport type { RepeatedRequest } from \"./quirks\";\nimport type { MapRequest } from \"./quirks\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { Message } from \"./lib/message\";\nimport type { Void } from \"./quirks\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service quirks.v1.Quirks\n */\nexport interface IQuirksClient {\n    /**\n     * @generated from protobuf rpc: GetAuthentication(quirks.v1.Void) returns (lib.Message);\n     */\n    getAuthentication(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Map(quirks.v1.MapRequest) returns (quirks.v1.MapRequest);\n     */\n    map(input: MapRequest, options?: RpcOptions): UnaryCall<MapRequest, MapRequest>;\n    /**\n     * @generated from protobuf rpc: MethodWithAReallyLongNameGmthggupcbmnphflnnvu(quirks.v1.Void) returns (lib.Message);\n     */\n    methodWithAReallyLongNameGmthggupcbmnphflnnvu(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Panic(quirks.v1.Void) returns (lib.Message);\n     */\n    panic(input: Void, options?: RpcOptions): UnaryCall<Void, Message>;\n    /**\n     * @generated from protobuf rpc: Repeated(quirks.v1.RepeatedRequest) returns (quirks.v1.RepeatedRequest);\n     */\n    repeated(input: RepeatedRequest, options?: RpcOptions): UnaryCall<RepeatedRequest, RepeatedRequest>;\n    /**\n     * @generated from protobuf rpc: Types(quirks.v1.TypesRequest) returns (quirks.v1.TypesRequest);\n     */\n    types(input: TypesRequest, options?: RpcOptions): UnaryCall<TypesRequest, TypesRequest>;\n}\n/**\n * @generated from protobuf service quirks.v1.Quirks\n */\nexport class QuirksClient implements IQuirksClient, ServiceInfo {\n    typeName = Quirks.typeName;\n    methods = Quirks.methods;\n    options = Quirks.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: GetAuthentication(quirks.v1.Void) returns (lib.Message);\n     */\n    getAuthentication(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Map(quirks.v1.MapRequest) returns (quirks.v1.MapRequest);\n     */\n    map(input: MapRequest, options?: RpcOptions): UnaryCall<MapRequest, MapRequest> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<MapRequest, MapRequest>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: MethodWithAReallyLongNameGmthggupcbmnphflnnvu(quirks.v1.Void) returns (lib.Message);\n     */\n    methodWithAReallyLongNameGmthggupcbmnphflnnvu(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Panic(quirks.v1.Void) returns (lib.Message);\n     */\n    panic(input: Void, options?: RpcOptions): UnaryCall<Void, Message> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Void, Message>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Repeated(quirks.v1.RepeatedRequest) returns (quirks.v1.RepeatedRequest);\n     */\n    repeated(input: RepeatedRequest, options?: RpcOptions): UnaryCall<RepeatedRequest, RepeatedRequest> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RepeatedRequest, RepeatedRequest>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Types(quirks.v1.TypesRequest) returns (quirks.v1.TypesRequest);\n     */\n    types(input: TypesRequest, options?: RpcOptions): UnaryCall<TypesRequest, TypesRequest> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<TypesRequest, TypesRequest>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/quirks.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"quirks.proto\" (package \"quirks.v1\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Timestamp } from \"./google/protobuf/timestamp\";\nimport { Message } from \"./lib/message\";\n/**\n * @generated from protobuf message quirks.v1.MapRequest\n */\nexport interface MapRequest {\n    /**\n     * @generated from protobuf field: map<string, string> string_string = 1;\n     */\n    stringString: {\n        [key: string]: string;\n    };\n    /**\n     * @generated from protobuf field: map<string, int32> string_int32 = 2;\n     */\n    stringInt32: {\n        [key: string]: number;\n    };\n    /**\n     * @generated from protobuf field: map<sint64, string> sint64_string = 3;\n     */\n    sint64String: {\n        [key: string]: string;\n    };\n    /**\n     * @generated from protobuf field: map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string = 4;\n     */\n    stringRepeatedString: {\n        [key: string]: MapRequest_RepeatedString;\n    };\n}\n/**\n * @generated from protobuf message quirks.v1.MapRequest.RepeatedString\n */\nexport interface MapRequest_RepeatedString {\n    /**\n     * @generated from protobuf field: repeated string value = 1;\n     */\n    value: string[];\n}\n/**\n * @generated from protobuf message quirks.v1.RepeatedRequest\n */\nexport interface RepeatedRequest {\n    /**\n     * @generated from protobuf field: repeated string string = 1;\n     */\n    string: string[];\n    /**\n     * @generated from protobuf field: repeated int32 int32 = 2;\n     */\n    int32: number[];\n    /**\n     * @generated from protobuf field: repeated quirks.v1.RepeatedRequest.Enum enum = 3;\n     */\n    enum: RepeatedRequest_Enum[];\n    /**\n     * @generated from protobuf field: repeated lib.Message message = 4;\n     */\n    message: Message[];\n}\n/**\n * @generated from protobuf enum quirks.v1.RepeatedRequest.Enum\n */\nexport enum RepeatedRequest_Enum {\n    /**\n     * @generated from protobuf enum value: KEY_0 = 0;\n     */\n    KEY_0 = 0,\n    /**\n     * @generated from protobuf enum value: KEY_1 = 1;\n     */\n    KEY_1 = 1\n}\n/**\n * @generated from protobuf message quirks.v1.TypesRequest\n */\nexport interface TypesRequest {\n    /**\n     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1;\n     */\n    timestamp?: Timestamp;\n    /**\n     * @generated from protobuf field: bool bool = 2;\n     */\n    bool: boolean;\n}\n/**\n * @generated from protobuf message quirks.v1.Void\n */\nexport interface Void {\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass MapRequest$Type extends MessageType<MapRequest> {\n    constructor() {\n        super(\"quirks.v1.MapRequest\", [\n            { no: 1, name: \"string_string\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"scalar\", T: 9 /*ScalarType.STRING*/ } },\n            { no: 2, name: \"string_int32\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"scalar\", T: 5 /*ScalarType.INT32*/ } },\n            { no: 3, name: \"sint64_string\", kind: \"map\", K: 18 /*ScalarType.SINT64*/, V: { kind: \"scalar\", T: 9 /*ScalarType.STRING*/ } },\n            { no: 4, name: \"string_repeated_string\", kind: \"map\", K: 9 /*ScalarType.STRING*/, V: { kind: \"message\", T: () => MapRequest_RepeatedString } }\n        ]);\n    }\n    create(value?: PartialMessage<MapRequest>): MapRequest {\n        const message = { stringString: {}, stringInt32: {}, sint64String: {}, stringRepeatedString: {} };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<MapRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRequest): MapRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* map<string, string> string_string */ 1:\n                    this.binaryReadMap1(message.stringString, reader, options);\n                    break;\n                case /* map<string, int32> string_int32 */ 2:\n                    this.binaryReadMap2(message.stringInt32, reader, options);\n                    break;\n                case /* map<sint64, string> sint64_string */ 3:\n                    this.binaryReadMap3(message.sint64String, reader, options);\n                    break;\n                case /* map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string */ 4:\n                    this.binaryReadMap4(message.stringRepeatedString, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    private binaryReadMap1(map: MapRequest[\"stringString\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringString\"] | undefined, val: MapRequest[\"stringString\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = reader.string();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_string\");\n            }\n        }\n        map[key ?? \"\"] = val ?? \"\";\n    }\n    private binaryReadMap2(map: MapRequest[\"stringInt32\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringInt32\"] | undefined, val: MapRequest[\"stringInt32\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = reader.int32();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_int32\");\n            }\n        }\n        map[key ?? \"\"] = val ?? 0;\n    }\n    private binaryReadMap3(map: MapRequest[\"sint64String\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"sint64String\"] | undefined, val: MapRequest[\"sint64String\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.sint64().toString();\n                    break;\n                case 2:\n                    val = reader.string();\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.sint64_string\");\n            }\n        }\n        map[key ?? \"0\"] = val ?? \"\";\n    }\n    private binaryReadMap4(map: MapRequest[\"stringRepeatedString\"], reader: IBinaryReader, options: BinaryReadOptions): void {\n        let len = reader.uint32(), end = reader.pos + len, key: keyof MapRequest[\"stringRepeatedString\"] | undefined, val: MapRequest[\"stringRepeatedString\"][any] | undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = MapRequest_RepeatedString.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default: throw new globalThis.Error(\"unknown map entry field for field quirks.v1.MapRequest.string_repeated_string\");\n            }\n        }\n        map[key ?? \"\"] = val ?? MapRequest_RepeatedString.create();\n    }\n    internalBinaryWrite(message: MapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* map<string, string> string_string = 1; */\n        for (let k of Object.keys(message.stringString))\n            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.stringString[k]).join();\n        /* map<string, int32> string_int32 = 2; */\n        for (let k of Object.keys(message.stringInt32))\n            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.stringInt32[k]).join();\n        /* map<sint64, string> sint64_string = 3; */\n        for (let k of Object.keys(message.sint64String))\n            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.LengthDelimited).string(message.sint64String[k]).join();\n        /* map<string, quirks.v1.MapRequest.RepeatedString> string_repeated_string = 4; */\n        for (let k of Object.keys(message.stringRepeatedString)) {\n            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);\n            writer.tag(2, WireType.LengthDelimited).fork();\n            MapRequest_RepeatedString.internalBinaryWrite(message.stringRepeatedString[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.MapRequest\n */\nexport const MapRequest = new MapRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MapRequest_RepeatedString$Type extends MessageType<MapRequest_RepeatedString> {\n    constructor() {\n        super(\"quirks.v1.MapRequest.RepeatedString\", [\n            { no: 1, name: \"value\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<MapRequest_RepeatedString>): MapRequest_RepeatedString {\n        const message = { value: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<MapRequest_RepeatedString>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRequest_RepeatedString): MapRequest_RepeatedString {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated string value */ 1:\n                    message.value.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MapRequest_RepeatedString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated string value = 1; */\n        for (let i = 0; i < message.value.length; i++)\n            writer.tag(1, WireType.LengthDelimited).string(message.value[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.MapRequest.RepeatedString\n */\nexport const MapRequest_RepeatedString = new MapRequest_RepeatedString$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RepeatedRequest$Type extends MessageType<RepeatedRequest> {\n    constructor() {\n        super(\"quirks.v1.RepeatedRequest\", [\n            { no: 1, name: \"string\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"int32\", kind: \"scalar\", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },\n            { no: 3, name: \"enum\", kind: \"enum\", repeat: 1 /*RepeatType.PACKED*/, T: () => [\"quirks.v1.RepeatedRequest.Enum\", RepeatedRequest_Enum] },\n            { no: 4, name: \"message\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }\n        ]);\n    }\n    create(value?: PartialMessage<RepeatedRequest>): RepeatedRequest {\n        const message = { string: [], int32: [], enum: [], message: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<RepeatedRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedRequest): RepeatedRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated string string */ 1:\n                    message.string.push(reader.string());\n                    break;\n                case /* repeated int32 int32 */ 2:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.int32.push(reader.int32());\n                    else\n                        message.int32.push(reader.int32());\n                    break;\n                case /* repeated quirks.v1.RepeatedRequest.Enum enum */ 3:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.enum.push(reader.int32());\n                    else\n                        message.enum.push(reader.int32());\n                    break;\n                case /* repeated lib.Message message */ 4:\n                    message.message.push(Message.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RepeatedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated string string = 1; */\n        for (let i = 0; i < message.string.length; i++)\n            writer.tag(1, WireType.LengthDelimited).string(message.string[i]);\n        /* repeated int32 int32 = 2; */\n        if (message.int32.length) {\n            writer.tag(2, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.int32.length; i++)\n                writer.int32(message.int32[i]);\n            writer.join();\n        }\n        /* repeated quirks.v1.RepeatedRequest.Enum enum = 3; */\n        if (message.enum.length) {\n            writer.tag(3, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.enum.length; i++)\n                writer.int32(message.enum[i]);\n            writer.join();\n        }\n        /* repeated lib.Message message = 4; */\n        for (let i = 0; i < message.message.length; i++)\n            Message.internalBinaryWrite(message.message[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.RepeatedRequest\n */\nexport const RepeatedRequest = new RepeatedRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TypesRequest$Type extends MessageType<TypesRequest> {\n    constructor() {\n        super(\"quirks.v1.TypesRequest\", [\n            { no: 1, name: \"timestamp\", kind: \"message\", T: () => Timestamp },\n            { no: 2, name: \"bool\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TypesRequest>): TypesRequest {\n        const message = { bool: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<TypesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypesRequest): TypesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* google.protobuf.Timestamp timestamp */ 1:\n                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);\n                    break;\n                case /* bool bool */ 2:\n                    message.bool = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* google.protobuf.Timestamp timestamp = 1; */\n        if (message.timestamp)\n            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* bool bool = 2; */\n        if (message.bool !== false)\n            writer.tag(2, WireType.Varint).bool(message.bool);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.TypesRequest\n */\nexport const TypesRequest = new TypesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Void$Type extends MessageType<Void> {\n    constructor() {\n        super(\"quirks.v1.Void\", []);\n    }\n    create(value?: PartialMessage<Void>): Void {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Void>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Void): Void {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: Void, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message quirks.v1.Void\n */\nexport const Void = new Void$Type();\n/**\n * @generated ServiceType for protobuf service quirks.v1.Quirks\n */\nexport const Quirks = new ServiceType(\"quirks.v1.Quirks\", [\n    { name: \"GetAuthentication\", options: {}, I: Void, O: Message },\n    { name: \"Map\", options: {}, I: MapRequest, O: MapRequest },\n    { name: \"MethodWithAReallyLongNameGmthggupcbmnphflnnvu\", options: {}, I: Void, O: Message },\n    { name: \"Panic\", options: {}, I: Void, O: Message },\n    { name: \"Repeated\", options: {}, I: RepeatedRequest, O: RepeatedRequest },\n    { name: \"Types\", options: {}, I: TypesRequest, O: TypesRequest }\n]);\n" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/search-service.client.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"search-service.proto\" (syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { SearchService } from \"./search-service\";\nimport type { IndexResponse } from \"./search-service\";\nimport type { IndexRequest } from \"./search-service\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { SearchResponse } from \"./search-service\";\nimport type { SearchRequest } from \"./search-service\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service SearchService\n */\nexport interface ISearchServiceClient {\n    /**\n     * @generated from protobuf rpc: Search(SearchRequest) returns (SearchResponse);\n     */\n    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse>;\n    /**\n     * @generated from protobuf rpc: Index(IndexRequest) returns (IndexResponse);\n     */\n    index(input: IndexRequest, options?: RpcOptions): UnaryCall<IndexRequest, IndexResponse>;\n}\n/**\n * @generated from protobuf service SearchService\n */\nexport class SearchServiceClient implements ISearchServiceClient, ServiceInfo {\n    typeName = SearchService.typeName;\n    methods = SearchService.methods;\n    options = SearchService.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: Search(SearchRequest) returns (SearchResponse);\n     */\n    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SearchRequest, SearchResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Index(IndexRequest) returns (IndexResponse);\n     */\n    index(input: IndexRequest, options?: RpcOptions): UnaryCall<IndexRequest, IndexResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<IndexRequest, IndexResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n" }, { path: "/Users/wham/code/kaja-twirp/ui/src/client/gen/search-service.ts", content: "// @generated by protobuf-ts 2.9.1 with parameter long_type_string\n// @generated from protobuf file \"search-service.proto\" (syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MESSAGE_TYPE } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message SearchRequest\n */\nexport interface SearchRequest {\n    /**\n     * @generated from protobuf field: string query = 1;\n     */\n    query: string;\n    /**\n     * @generated from protobuf field: int32 page_number = 2;\n     */\n    pageNumber: number;\n    /**\n     * @generated from protobuf field: int32 result_per_page = 3;\n     */\n    resultPerPage: number;\n}\n/**\n * @generated from protobuf message SearchResponse\n */\nexport interface SearchResponse {\n    /**\n     * @generated from protobuf field: repeated Result results = 1;\n     */\n    results: Result[];\n}\n/**\n * @generated from protobuf message Result\n */\nexport interface Result {\n    /**\n     * @generated from protobuf field: string url = 1;\n     */\n    url: string;\n    /**\n     * @generated from protobuf field: string title = 2;\n     */\n    title: string;\n    /**\n     * @generated from protobuf field: repeated string snippets = 3;\n     */\n    snippets: string[];\n    /**\n     * @generated from protobuf field: bool is_ad = 4;\n     */\n    isAd: boolean;\n}\n/**\n * @generated from protobuf message IndexRequest\n */\nexport interface IndexRequest {\n    /**\n     * @generated from protobuf field: Result result = 1;\n     */\n    result?: Result;\n    /**\n     * @generated from protobuf field: Position position = 2;\n     */\n    position: Position;\n    /**\n     * @generated from protobuf field: uint64 additional_copies = 3;\n     */\n    additionalCopies: string;\n}\n/**\n * @generated from protobuf message IndexResponse\n */\nexport interface IndexResponse {\n    /**\n     * @generated from protobuf field: Result result = 1;\n     */\n    result?: Result;\n}\n/**\n * @generated from protobuf enum Position\n */\nexport enum Position {\n    /**\n     * @generated from protobuf enum value: POSITION_TOP = 0;\n     */\n    TOP = 0,\n    /**\n     * @generated from protobuf enum value: POSITION_BOTTOM = 1;\n     */\n    BOTTOM = 1\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass SearchRequest$Type extends MessageType<SearchRequest> {\n    constructor() {\n        super(\"SearchRequest\", [\n            { no: 1, name: \"query\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"page_number\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ },\n            { no: 3, name: \"result_per_page\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    create(value?: PartialMessage<SearchRequest>): SearchRequest {\n        const message = { query: \"\", pageNumber: 0, resultPerPage: 0 };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<SearchRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string query */ 1:\n                    message.query = reader.string();\n                    break;\n                case /* int32 page_number */ 2:\n                    message.pageNumber = reader.int32();\n                    break;\n                case /* int32 result_per_page */ 3:\n                    message.resultPerPage = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string query = 1; */\n        if (message.query !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.query);\n        /* int32 page_number = 2; */\n        if (message.pageNumber !== 0)\n            writer.tag(2, WireType.Varint).int32(message.pageNumber);\n        /* int32 result_per_page = 3; */\n        if (message.resultPerPage !== 0)\n            writer.tag(3, WireType.Varint).int32(message.resultPerPage);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message SearchRequest\n */\nexport const SearchRequest = new SearchRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SearchResponse$Type extends MessageType<SearchResponse> {\n    constructor() {\n        super(\"SearchResponse\", [\n            { no: 1, name: \"results\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Result }\n        ]);\n    }\n    create(value?: PartialMessage<SearchResponse>): SearchResponse {\n        const message = { results: [] };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<SearchResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated Result results */ 1:\n                    message.results.push(Result.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated Result results = 1; */\n        for (let i = 0; i < message.results.length; i++)\n            Result.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message SearchResponse\n */\nexport const SearchResponse = new SearchResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Result$Type extends MessageType<Result> {\n    constructor() {\n        super(\"Result\", [\n            { no: 1, name: \"url\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"title\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"snippets\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"is_ad\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Result>): Result {\n        const message = { url: \"\", title: \"\", snippets: [], isAd: false };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<Result>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Result): Result {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string url */ 1:\n                    message.url = reader.string();\n                    break;\n                case /* string title */ 2:\n                    message.title = reader.string();\n                    break;\n                case /* repeated string snippets */ 3:\n                    message.snippets.push(reader.string());\n                    break;\n                case /* bool is_ad */ 4:\n                    message.isAd = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string url = 1; */\n        if (message.url !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.url);\n        /* string title = 2; */\n        if (message.title !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.title);\n        /* repeated string snippets = 3; */\n        for (let i = 0; i < message.snippets.length; i++)\n            writer.tag(3, WireType.LengthDelimited).string(message.snippets[i]);\n        /* bool is_ad = 4; */\n        if (message.isAd !== false)\n            writer.tag(4, WireType.Varint).bool(message.isAd);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message Result\n */\nexport const Result = new Result$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass IndexRequest$Type extends MessageType<IndexRequest> {\n    constructor() {\n        super(\"IndexRequest\", [\n            { no: 1, name: \"result\", kind: \"message\", T: () => Result },\n            { no: 2, name: \"position\", kind: \"enum\", T: () => [\"Position\", Position, \"POSITION_\"] },\n            { no: 3, name: \"additional_copies\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/ }\n        ]);\n    }\n    create(value?: PartialMessage<IndexRequest>): IndexRequest {\n        const message = { position: 0, additionalCopies: \"0\" };\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<IndexRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexRequest): IndexRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* Result result */ 1:\n                    message.result = Result.internalBinaryRead(reader, reader.uint32(), options, message.result);\n                    break;\n                case /* Position position */ 2:\n                    message.position = reader.int32();\n                    break;\n                case /* uint64 additional_copies */ 3:\n                    message.additionalCopies = reader.uint64().toString();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: IndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* Result result = 1; */\n        if (message.result)\n            Result.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* Position position = 2; */\n        if (message.position !== 0)\n            writer.tag(2, WireType.Varint).int32(message.position);\n        /* uint64 additional_copies = 3; */\n        if (message.additionalCopies !== \"0\")\n            writer.tag(3, WireType.Varint).uint64(message.additionalCopies);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message IndexRequest\n */\nexport const IndexRequest = new IndexRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass IndexResponse$Type extends MessageType<IndexResponse> {\n    constructor() {\n        super(\"IndexResponse\", [\n            { no: 1, name: \"result\", kind: \"message\", T: () => Result }\n        ]);\n    }\n    create(value?: PartialMessage<IndexResponse>): IndexResponse {\n        const message = {};\n        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });\n        if (value !== undefined)\n            reflectionMergePartial<IndexResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexResponse): IndexResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* Result result */ 1:\n                    message.result = Result.internalBinaryRead(reader, reader.uint32(), options, message.result);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: IndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* Result result = 1; */\n        if (message.result)\n            Result.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message IndexResponse\n */\nexport const IndexResponse = new IndexResponse$Type();\n/**\n * @generated ServiceType for protobuf service SearchService\n */\nexport const SearchService = new ServiceType(\"SearchService\", [\n    { name: \"Search\", options: {}, I: SearchRequest, O: SearchResponse },\n    { name: \"Index\", options: {}, I: IndexRequest, O: IndexResponse }\n]);\n" }] };
export function getClient(name: string, transport: RpcTransport): ServiceInfo | undefined { switch (name) {
    case "QuirksClient": return new QuirksClient(transport);
    case "SearchServiceClient": return new SearchServiceClient(transport);
} return undefined; }
